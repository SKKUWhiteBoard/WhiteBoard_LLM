If you have a complex polyhedron, we found general unfoldings. We proved one of them. For non-convex polyhedra, we know this is too much to hope for. Even if it's topologically convex, there's not always an edge unfolding. That was the tetrahedral Witch's Hat. But for general unfolding, we don't know. So today's lecture is actually mostly about these two open problems and different variations of it that we know how to solve. model. At the end, there'll also be some stuff about the reverse direction folding, but mostly, it will be about unfolding. There's a third kind of unfolding which we call vertex unfolding, and it's kind of like a hinged dissection. You're only allowed to cut on edges. And in fact, we will cut on all the edges because that'll be the most flexible. Every edge gets cut, but you're going to leave intact certain vertices to make one. Every connected triangulated manifold -- this is a very general result. It actually holds in any dimension. So this works both for convex and for non-convex. The only catch is that every face has to be a triangle. We've even implemented this algorithm here. A bunch of random points on a sphere. So you get this nice chain of triangles, don't intersect each other, and this will fold up into that 3D polyhedron on the left. Here's some bigger examples, hundreds of vertices. Amazing. It's an open problem for something like a cube where you actually have quadrilateral faces. So the way we prove this is to construct what we call a facet-path. This is a path that alternates between visiting faces, triangles, and vertices. It should visit every facet, every triangle, exactly once. Vertices you can visit multiple times, although I think it's a bad idea to visit the same vertices twice in a row. Other than that, you can visiting a vertex more than once. than once. Once you have this facet-path, you're basically golden because you can lay it out without overlap. So if you have a triangle and you have some corners of it that are hinged to adjacent triangles, you can rotate that triangle 'til it fits in a vertical slab. And the hinges are on the ends of the slab, so each triangle lives in its own slab. Slabs don't intersect. No intersection. The hard part is really getting this path. It's a little bit nontrivial with obtuse triangles. They don't necessarily just lie along the horizontal line. to work for discs just as well. It should work for anything that's connected. So ideally, I cut it all apart into lots of little triangles, but it has to stay connected. Why not? So I can add some cuts until I get down to a spanning tree of the faces. OK. For whatever reason, this is the triangulation I chose, andThis is the unfolding I chose. But just keep cutting edges until cutting an edge would cause it to disconnect. So the maximal set of cuts, there are many ways to do it. going to cut this up into a facet-path. Instead of being given a polyhedron, we're given a disc like this, a triangulated disc, and we have to deal with it. We're going to visit every triangle exactly once, and passing through vertices. Distances don't matter. It's just topology. You could think of it as a circle with some decomposition into triangles, if you like, but that's maybe harder to think about. In a triangulated polygon, we usually call them ears. These are leaves and in that tree which call the dual tree. So cut edges until you can't anymore, so until cutting would disconnect. So this means what you're left with will be sort of a tree of faces. There'll be no cycles because if there was a cycle, you could cut one of the edges, and it wouldn't fall apart. So obviously, there's a tree here. Now, trees have leaves. That's our favorite lemma lately. original thing, we think of this triangle as being an ear, and this triangle is an ear. Now, the next step is to color what are called the second-level ears. I'll call them the remaining ears, if you remove those ears, what would, then, become an ear? All right. Yeah, that's kind of yellowish. So this would become an ears. And I'm going to stop there, just two levels. What could I get in this process? I mean what it looks like I'm getting is I get an ear and a triangle. then, a second-level ear. It could be a little more general than that. Maybe, for example, if I had a triangle like this, both of these would be first-level ears, and then, this would become a second level ear. That's it. Unless there's only four pieces left. Right? PROFESSOR: Sorry, what do you mean? AUDIENCE: You could have three ears. PROFessor: You can have three years. would only happen at the very end. But yeah, this could be first-level ears, and this is the second-level ear. Good point. Most of the time, we will either get something like this, the rest of the polygons over here. This is, most of thetime, what you'll get in the base case of this induction. I'm going to pluck off these ears and keep making the thing smaller. At the end, there are a few cases to think about. picture, or if you just have two maybe. Well, I guess-- Yeah, because then, these are both first-level ears. It doesn't look quite the same. Or maybe just a Mickey Mouse because those are all-- Well, it probably works. But for these cases, I just need to check that I can find a facet-path. So for example, this one,I just visit the triangle. This one-- I don't know-- I do it like that. In fact, I can make it a cycle if I want to go crazy. This is actually the base case, if you will. So in general, I just pluck off two or three triangles, repeat until I get one of the base cases. So imagine those guys as being done. I'm left with these four triangles, actually, a little boring because I don't get the Mickey Mouse case. But then, this will be an ear. This will be a second-level ear. And so I'll end up doing this. And this is an ear, and this will Be an Ear. even attached to these cycles, so it's kind of a problem. That's step five is we're going to fix all the problems. Connect cycles together. So that's a local change, and now, it will be one big cycle. We've probably seen this trick once or twice before, I think in the Mountain Valley assignment stuff. So, that'd be a great title. That would be a good title for a book. It would be called, Connecting Cycles. here I have, for example, these two triangles, which are adjacent, but the paths don't meet. So I'm preserving, at all times, that I'm a facet path, and I'm merging components. So by the end, I'll have one big component. Now, I have a facet-path for a triangulated cube. Actually, it's probably the top one, something like that, might be. I may not have matched exactly what's in the textbook. it can connect to other things. That will cause you make two vertices of odd degree. But that's OK because there's still an Euler path that starts at one of the vertices and visits all the other edges. And I just need a path. You can actually characterize when you get a cycle. It's when the original thing is not too colorable, I think. Anyway, that's vertex unfolding. I think we solved most of it in like an afternoon. We had this idea, and then, we solved it kind of quickly. natural version is to think about what we were originally trying to attack, convex polyhedra. This turned out to not require convexity. But what about convexpolyhedra, not triangulated? Is there always a vertex unfolding? We don't know about edge unfoldings. And the answer is no. Well, no that's not right. Sorry. The answer is we don'tknow. What's annoying about this example is that there's no facet-path. So there are two things that could go wrong. can't-- let's say if your two hinges were here and here, if that's where you attach two adjacent pieces, you can't fit that in a vertical strip. So also this layout problem doesn't work if you have something more than triangles. It's even open for non-convex. At the very least, you need to forbid faces having holes. If you remember this example, the box on a box, this also doesn't have a vertex unfolding because still, this guy has to fit in that little square hole. An orthogonal polyhedron is one where all the faces are perpendicular to one of the three coordinate axes. Google SketchUp makes it really easy, and you can add shadows and texture. There are three kinds of faces. There's the ones perpendicular to x, like these guys. And there's the one perpendicular to y. That's all the yellow faces. And then there are the ones parallel to z. So we call them x- faces, y-faces, z-faces. if you can voxelize it. So this is really a lot of stuff. I would love to generalize this approach arbitrary polyhedra, but that's the big open question. So what do we do? Well, we're going to single out, from this color coding, the y-faces. Just color them yellow. Then, there's all the other faces. Well, they form bands. They're cycles. They go around in a loop. A lot of them here, I've just drawn as rectangular loops, but in general, all those wooden faces, the x and z-faces, will form a bunch of loops. out here, and then, it has two children. There will be some front children and some back children. You pick some root arbitrarily and then you have children going off of there. Now, if you're orthogonal polyhedron has genus 0-- it's topologically a sphere-- this will be a tree. If it's like a doughnut, it will have a cycle. So we're going to exploit that that dual drawing, how the bands are connected together, is like a dual drawing. tree. A band is a cycle of x and z-faces, and they are connected together in a tree. The challenge, I guess you could say, is avoiding overlap. It's how do you piece those bands together and then, have room for the yellow faces to attach on the sides, no overlap? But it can be done with the awesome, crazy idea that we'll get to shortly. But it's going to start out kind of like a depth-first traversal of this tree. of innocent, but the general approach is always proceed rightward in the unfolding. So the unfolding will look something like this. We start here, and we might go up and down, but we never go left. And then, that's going to be all the band faces. All the band stuff will be connected like that, and then, there'sGoing to be yellow faces that can just hang off the sides. So these are the y-faces. As long as I get the band to do this, y- faces can hang up and. down. It's not going to intersect anybody. but I could not turn right again. I have to turn left next. I can actually do two left turns in a row. As long as I adhere to those rules, I'm fine. We're going to subdivide into a lot of little pieces, an exponential number of pieces, so this is kind of hard core. So here is one example. This is a leaf. So trees have leaves, and at the end, we're Going to have to visit a Leaf. So this is one box. There's this funny view. you can see like a mirror on the bottom. And our parent tells us you have to start at s, and it says you better finish at t. And I want the property that if initially, I think, initially, you're going right. No, it looks like initially,you're going up. It matters. You can do stuff, and then, at the end, you should still be facing up. And normally, that would be hard to do. If you just tried to visit one. face at a time, you can't do that, but if you visit faces multiple times and kind of weave around in a clever way, you could do it. In fact, I basically just zigzagged. So I start at s. I go up. I turn right. Now, I better turn left. I going down over here, up there. I turned left. Then, I turned right. So if you follow along here, I just turn right here. So now, I go down here. work if it was rotated 90 degrees. It's really powerful. It also works if t is on the other side of s. You could do sort of the mirror image traversal. Now, obviously, I didn't cover the entire surface. I'm leaving room for later, but if this was all I was going to do, I would actually sort of fill out all those strips, just kind of extend them. It just makes this kind of fatter. So this got a little bigger. I've got the first half and then, the second half. This is really glued up there. also, in this case here, we're imagining-- oh, this is actually two of them. Two of these strips joined together. They just attach up and down. They're not going to intersect anything because this is not actually below this. This is way over here. So that's the leaves, and I still haven't gotten to the exciting part. So imagine you have a band. Just going to represent that by this big rectangle, and it has a bunch of children. Remember, it can have front children. And it could have back children up in the y-coordinate. Don't have to think about whether it turned, don't want to have to depend on that. Initially, you must be facing up. And I could handle two right turns, as long as the next thing I did was a left. So I come into this thing saying, look, you're facing-- this is facing down. Now, you better turn left next, and by the end, I still want to be facing down again. And here, I'm wrapping around to here because this is actually a band that cycles around. You just have to slightly switch your orientation, but again, preserve that you're doing left-left-right-right. You tell each of the children which way you're initially going, and they can deal with it. It's just a little hard to see because I'm drawing it on a flat surface. But if it was on a ring, it would be much clearer. Just going left and right and left andright, alternating direction. At some point, I get to here. I loop around. I make a little wiggle at some point. the lavender edge is at t10. Now what? We want to come back here, and I'm not allowed to sort of intersect myself. That would be the paper going into two parts of this unfolding, so that's not good. But I have all this space, so natural thing is to just wander from there back down to here, using up the space. So it's going to look like this. Everything that you did, you just undo. At every level of the tree, you're going to double what was below you. So this recursive thing from this structure ends up getting doubled. At the parent structure, it will also get doubled. that's why you get exponential, in general. On the other hand, if your tree happens to be nice and balanced, doubling is not so bad because here you'll have constant. This a double everything below, but there's only log n levels. So is that linear? It should be about linear. It's certainly 2 to the theta log n, and it matters what this constant is. I think it's n or maybe n squared, but not too bad. So if you're lucky and the just the structure of your tree. of your bands is balanced, it's good. Exponential number cuts is a lot, but it works. You can unfold every orthogonal polyhedron this way. I would love to see an implementation of this algorithm. You could only do it in a computer because you'd be splicing into all these little things, and it would fall apart. Jason? You've been making these, I guess, gadgets [INAUDIBLE] voxel would attach just by a side. You Could imagine it attaching at a corner attaching to multiple sides. I'm not quite sure what you're imagining. Maybe something like that where they share a partial face here? AUDIENCE: Yeah, but it could also be inset into the [INAUDIBLE]. PROFESSOR: If it's inset, I'm cutting with every-- I maybe didn't mention that-- through every vertices. So that will cut into lots of little strips, and then, there's no sort of overlap with the strips. I'm subdividing into little substrips. an edge unfolding of that. Do those exist? These are what we call grid unfoldings. This only makes sense for orthogonal polyhedra. It might be easy. Well, it's not easy. The next best thing you could hope for is to refine. So you take each of the grid rectangles and divide it into k by k, so subgrid. We had lots of examples where those fail, like the cube with little bites taken out of the edges. But grid unfolding, you get lots of subdivision. So ideally, k is one, and you're not subdividing at all. But maybe, you take every rectangle, divide it in half. Maybe that's enough to then be edge unfoldable. That would be sort of a refined level two grid-like unfolding. There are a ton of results about this. They're all partial. But one thing you could do, with merely 5 by 4 refinement, is something called Manhattan Towers. Let me show you a picture of Manhattan Tower. This is more crazy examples of what it's like to visit. staircase. It's, again, to make everything keep going to the right, but here, they find a clever way to visit all the faces without having to revisit, basically, at all, just visiting each face a constant number of times. So here, the floor is a rectangle. That's the only additional requirement, and again, as you slice upwards, things only get smaller. Here's a. Another case looks like this. Boom! AUDIENCE: Woah. Isn't that cool? I'll play it again. The idea of bands came from an old paper in 1998, from the beginning. It's just I have a band, and then, I stack another band on top. So that's a little different. With towers, I could have multiple towers here. I really only want one tower built slab by slab. These things we don't know how to grid unfold. That's an open problem, but if you refine just in z by a factor of 2, that's enough to unfold. So 1 by 2 refinement is enough for orthostacks. is what I have written here. I haven't actually read that paper. What else do I have? Orthotubes. Orthotube is just sort of thickness one orthogonal tube. It could even be closed, I think, in a loop, but here I've shown it open. And here, grid unfolding is enough. You just do all the grid refinement. You could even just do it locally. Technically, there's a slice here that might slice over here, but you don't have to worry about that. other open problems. This was genus 0. Interesting question is can you do genus higher than 0? Orthogonal polyhedra. I would guess so, but I'm not sure. I think the biggest question is, can you make this non-orthogonal? But then, the bands get messy. Haven't been able to do that. All right. I'm going to take a break from unfolding now and switch the other direction of folding. So with folding, we're imagining we're given some polygon, and we'd like to make a polyhedron out of it. It's exactly the reverse of what we've been thinking about. When is this possible? The opposite of cutting is gluing. We'll be more formal about defining gluing, I think, next lecture. But you end up gluing-- I want to make something, let's say-- in fact, we're always going to talk about folding convex polyhedra. There's very little work on the non-convex case, though, there was actually a recent result. I have to be able to draw a picture like this. Question is when do these gluings make a polyhedron? That is the question we will be answering next class. like yet in 3D. In particular, you can compute shortest paths here. I could compute the shortest path from this point to this point you might think is a straight line. But no, it's not. Or maybe it is. A little tricky. So you have to think about it for a while, but it turns out, in polynomial time,. That's cool. What I want to show now is that suppose you could make a convex polyhedron in this This is Cauchy's rigidity theorem. I claim you can only make one, never more than one from the same gluing. So I've defined locally what this thing is. It's like a piece of paper. I can mangle it around. If I want to make something convex, there's only one thing it could possibly make. Finding out what that one thing is is quite a challenge, but at least, we can prove that it's unique. There's a lot of ways to state this theorem, but one way. is to say, suppose you have two convex polyhedra, and suppose they came from the same sort of intrinsic geometry. So there's the geometry of the faces, and there's how they're connected together. Different faces can be different, but they're identical in pairs. That's what we're claiming. Is this one any better? Yeah, it's better. This is an old theorem. You may have heard of Cauchy, famous French mathematician. He proved a lot of things. This theorem he didn't actually prove. Cauchy-Steinitz rigidity theorem is often attributed to both of them. It's sort of a proof by contradiction. We want to prove uniqueness. So we're supposing, well, maybe, there's two polyhedra, p and p prime, and they're combinatory equivalent and have matching faces congruent. And then, I want to slice them with an epsilon sphere, a radius sphere centered at v and v prime. But this is not true if you allow non-convex realizations. In a convex situation, here's what the slice looks like. I get a polygon on the sphere. Convex spherical polygons, convex because the polyhedra are convex. I actually get two of them. One for p, one for p prime. If p and p prime are supposed to be different, then there must be two angles that differ. That's why this is about rigidity. Maybe the convex polyhedron could flex. Maybe it's flexible. Maybe there are two different states. are the same and all the angles at which you join them are the same. There's no flexibility there, but it could be there are pluses and minuses. But if there's going to be a problem with this theorem, there have to be pluses or minuses, that's the proof by contradiction. So we have-- it's a spherical polygon. I'm going to draw it more like a polygon, maybe some pluses, some zeroes, some minuses,. whatever. a sphere. Think of it is as almost flat. What that would mean is there's some other way to draw this thing. Basically, there's a way to flex this linkage so that all of these angles increase and this one stays the same. How could I get a polygon where all of the angles increases and still be convex? Ain't possible. Why is it not possible? I think we've used this fact a couple lectures ago. It's not possible by something called the Cauchy Arm Lemma. And here's the thing. If you have a convex chain but open chain here. There's a missing bar. if you open all the angles in a convex chain, then this distance increases. So I put plus. Some of them could stay the same, but then, this distance will increase, as long as you stay convex. But in this situation, we know that both the initial position in p and its target position in prime are both convex, so the distance can't increase. The edge lengths are fixed. So if they're all pluses and zeroes, or all minuses and zero, the same is. true just viewing p prime as p and p as p prime. So if there's anything in there other than zeroes, there has to be at least one plus, at leastone minus. In particular, there have to be two alternations. Alternation is either going from plus to minus or from minus to plus. So it could be something like plus, plus,plus, minus, minus,. minus,minus, minus. Plus, plus. Whatever. OK? Maybe that's your polygon. Is that possible? Whatever. These angles down here are decreasing. Therefore, this distance decreases. The angles up here are all increasing. Therefore,. this distance increases. Can't have both. So this is also not possible. So in fact, you have to have at least four alternations. It's always even. And so it has to be at least a bunch of pluses, then a bunch. of minuses. Then a bunch more pluses and then more minuses, and so on. might think, well, what happens if there's only three vertices. Well, yeah, you can't have those four alternation because if you have a triangle, even on the sphere, triangles are rigid. So you would know if I had a degree 3 vertices, locally that thing is rigid. It can't flex at all. We're only interested in cases where it might flex locally at a vertex like the pentagon, like a quadrilateral. All right. So what? This was true at every vertices that was not entirely zero. a capital V. We'll get two different answers, but we know they must end up being the same. And then, we'll get a contradiction. The other natural way to count angles is by looking at the faces. It's sort of the dual perspective. Every phase has a bunch of angles that have some degree or whatever. They're really kind of the same thing. Oh, here was Cauchy's Arm Lemma. Beautiful. If you look at the alternations as you walk around a vertex versus as you walked around a face, The labels are on the edges of the graph. They could be zero, plus, or minus. And if I have an alternation from plus to minus, view from the vertex, it's also an alternations as I walk around the face. So instead of counting by walking around all the vertices-- which are just did, and I got at least four at every vertex-- let's do it from the perspective of the faces. And we're in this weird subgraph of plus and minus edges, so assume there are no zeroes. All right. have a face of 2 k or 2 k plus 1 edges, then it will have, at most, 2 k alternations. I'm going to try and prove an upper bound, sandwich it between, and show that, actually, the upper bound is smaller than the lower bound, and that's a contradiction. So this is kind of obvious. Right? If you have 2 k vertices, no more than 2k alternations, slight, the place where we're making a little improvement is for the odd case. The average degree is 5? Slightly under 6, 4, 3, 2, 1? Let's see. Should be like 3 n minus 6 edges, so that should be 3. So most of the faces are going to have low degree. So 3 and 5 really matter, but out here, it doesn't matter so much. This is kind of a magical proof. It shouldn't be intuitive where it came from, but it's really beautiful. You'll see as it all comes together. conveniently relates vertices to faces, but it involves edges. The number of edges is half the sum of the degrees of the vertices. If I look at every face and I count the number of edge, I will end up counting every edge twice, once from each side. So this is half 2-- No, sorry. Not the number faces. What am I doing? Half theSum of the Degrees of the faces. That's handshaking lemma from way back when. is half-- what is the degree of degree 3 faces? 3. What is thedegree of degree 4 faces? 4. And so on. So now, things are starting to look similar, and I want to get some cancellation going on. Use my cheat sheet here. I'm going to rewrite this formula as V equals 2 plus E minus F. OK? All I did here was decrease by-- well, because there's a half out here, I decrease each coefficient by 2, nothing surprising. 4V is, at most, this number, and yet, it's also equal to this number. It can't be both. This number's at least 8 larger than this number; it could be even more larger. This works as long as there is at least one face, meaning 1 plus or minus because we're only looking at the subgraph plus and minus edges. And that is Cauchy's rigidity theorem. And in our situation, here, we don't actually necessarily know where the creases are. We just know how things are glued together. compute the shortest paths between all pairs of vertices, something like this picture, except you don't know what it looks like in 3D. You know every edge must be a shortest path. So the edges are some subset of these guys. And so you've got lots of little convex polygons here. We know it must make a convex polyhedron. If it made two, Cauchy's rigidity theorem would tell you that they're the same. So even once you fix the gluing, you know that there's a unique convex realization.