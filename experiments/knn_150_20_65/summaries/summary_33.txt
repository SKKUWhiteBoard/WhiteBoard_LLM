The 60002 course is the second half of the 600 program. The main topic is computational models. The final exam will be based upon all of the above. The lectures will be a bit faster paced than 60001. The course is really less about programming and more about dipping your toe into the exotic world of data science. It will be taught in Python, but there will be additional bits of Python as well as some comments about software engineering, how to structure your code, more emphasis in using packages. Science is moving out of the wet lab and into the computer. Increasingly, there is an increasing reliance on computation rather than traditional experimentation. We'll talk about three kinds of models-- optimization models, statistical models, and simulation models. An optimization model is a very simple thing. We start with an optimization model and then go on to other types of models, such as statistical models or simulation models, which can be used to predict the future of a given area of science. For example, a climate change model. We can build models that sort of explain how the climate has changed over the millennia. with an objective function that's either to be maximized or minimized. We then often have to layer on top of that objective function a set of constraints, sometimes empty, that we have to obey. So for, example, if I'm going from New York to Boston, I might want to find a route by car or plane or train that minimizes the total travel time. We use these things all the time. I commute to work using Waze, which essentially is solving-- not very well, I believe-- an optimization problem to minimize my time. The most obvious solution is brute force, but that's not very practical. Here's some code that uses greedy. Takes in the items, the constraint, in this case will be the weight, and just calls greedy, but with the keyfunction and prints what we have. Used greedy by value to allocate and calls testGreedy with food, maxUnits and Food.getValue. And then we have something pretty interesting. What's going on with this lambda? So here we're going to be using greedy by density to allocate, sorry, greedy by cost. We want the cheaper items to get chosen first because they have fewer calories. Python's test function testGreedy takes foods and the maximum number of units. It's going to go through and test all three greedy algorithms. When we use greedy by cost, I get 318 happiness points and a different menu, the apple, the wine, the cola, the beer, and the donut. I've lost the pizza and the burger. And here's another solution with 318, apple, wine-- yeah, all right. So I actually got the same solution, but it just found them in a different order. Lambda is used to create an anonymous function, anonymous in the sense that it has no name. Lambda does is it builds a function that evaluates that expression on those parameters and returns the result of evaluating the expression. So instead of writing def, I have inline defined a function. Here you have it or maybe you don't, because every time I switch applications Windows decides I don't want to show you the screen anyway. This really shouldn't be necessary. Why it keeps forgetting? Anyway, so here's the code.