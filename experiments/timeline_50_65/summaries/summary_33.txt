The following content is provided under a Creative Commons license. Your support will help MIT OpenCourseWare continue to offer high quality educational resources for free. To make a donation or to view additional materials from hundreds of MIT courses, visit MIT Open CourseWare at ocw.mit.edu. JOHN GUTTAG: All right, welcome to MIT Open courseWare. We'll be back next week with a look at some of the other courses available on the site. Back to the page you came from. the 60002, or if you were in 600, the second half of 600. What's the workload? There are problem sets. They'll all be programming problems much in the style of 60001. And the goal-- really twofold. The goal is to make the world a better, safer, more efficient place. The 60002 is a new program that aims to do just that. It's called the 60002 and it's being developed by a group of people in New York. were mostly about you learning to be a programmer. A lot of that carries over. So a lot of it is to improve your skills, but also there's a lot more, I would say, conceptual, algorithmic material in 60002, he says. "No one learns to being a programmer in half a semester," he adds. "It's a long way from that to being able to do it in a day or two" "There's a much more to come," he says, "in terms of how we think about the world and how it works" and the problem sets are designed to help cement that as well as just to give you programming experience. Finger exercises, small things. If they're taking you more than 15 minutes, let us know. They really shouldn't, and they're generally designed tohelp you learn a single concept, usually a concept. Usually a problem set is just a series of questions and answers. If you have any questions, please email them to jennifer.smith@mailonline.co.uk or tweet them @jennifersmith. programming concept. Reading assignments in the textbooks, I've already posted the first reading assignment, and essentially they should provide you a very different take on the same material we're covering in lectures and recitations. We've tried to choose different examples for lectures and from the textbooks for the most part, and we've tried not to use the same examples for all of them. We'll post the rest of the reading assignments as we go along, so keep an eye out for them. Back to the page you came from. so you get to see things in two slightly different ways. There'll be a final exam based upon all of the above. All right, prerequisites-- experience writing object-oriented programs in Python, preferably Python 3.5. Familiarity with concepts of computational complexity. You'll see even in today's lecture, we'll be assuming that. We'll be asking you to solve problems in two different ways, so that we can all get a better idea of what's going on. If you took 60001 or you took the 60001 advanced standing exam, you'll be fine. Odds are you will be fine anyway, but that's the safest way to do it. So the programming assignments are going to be a bit easier, at least that's what students say. If you've already taken 60001, you're likely to be fine with the rest of the program. If not, you may need to take a refresher course in the next few weeks. have reported in the past, because they'll be more focused on the problem to be solved than on the actual programming. The lectures will be-- and maybe I'm speaking euphemistically-- a bit faster paced. So hang on to your seats. And the course is really quite interesting. It's a little more abstract than some of the other courses I've been involved in, but it's still a great course. I'm looking forward to it. I've learned a lot in the last few months. less about programming and more about dipping your toe into the exotic world of data science. There'll be a few additional bits of Python. Today, for example, we'll talk about Lambda abstraction. Inevitably, some comments about software engineering, how to structure software. We do want you to hone your programming skills. We'll also talk about data science and data analysis in the next episode of the series, "Data Science in the Bigbang" on Monday, November 14 at 9pm ET. your code, more emphasis in using packages. Hopefully it will go a little bit smoother than in the last problem set in 60001. And finally, it's the old joke about programming that somebody walks up to a taxi driver in New York City and says, "I'm lost. How do I get out of this situation?" It's a good time to be a programmer, but it's also a bad time to get into a car with someone who doesn't know how to drive. get to Carnegie Hall?" The taxi driver turns to the person and says, "practice, practice, practice" The main topic of the course is what I think of as computational models. How do we use computation to help people get to their goals? The only way to learn to program is practice, Practice, Practice. That's what this course is all about. It's about learning to program, and how to do it in a way that helps people get where they want to go. understand the world in which we live? What is a model? To me I think of it as an experimental device that can help us to either understand something that has happened, to sort of build a model that explains phenomena we see every day, or to model that will help us understand the world we live in. To me, a model is a device that helps us to understand something, to build a models that can explain phenomena. to me, it's an experimental devices that canhelp us understand something. to help us understanding the world. allow us to predict the future, something that hasn't happened. So you can think of, for example, a climate change model. We can build models that sort of explain how the climate has changed over the millennia. And then we can build probably a slightly different model that might predict. that might be a little bit more accurate than the previous one. It's a very complex process, but we're getting closer to the end of the first stage of the process, and we're starting to see the results. what it will be like in the future. So essentially what's happening is science is moving out of the wet lab and into the computer. Increasingly, I'm sure you all see this-- those of you who are science majors-- an increasing reliance on computation rather than traditional experimentation. As we'll see in the next few weeks, we'll look at some of the ways in which computers are changing the way we think about science and the world we live in. We'll also look at how technology is changing our understanding of the universe. talk about, traditional experimentation is and will remain important, but now it has to really be supplemented by computation. We'll talk about three kinds of models-- optimization models, statistical models, and simulation models. So let's talk first about optimization models. An optimization model is a very simple thing. We start with an optimization model, and then we talk about statistical models. And then we go on to a simulation model, which is a much more complex thing. And so on and so on. with an objective function that's either to be maximized or minimized. So for, example, if I'm going from New York to Boston, I might want to find a route by car or plane or train that minimizes the total travel time. So my objective function would be the number of times I want to travel. For example, I would want to go to Boston by car, plane, or train. I would like to minimize my travel time by less than one hour. I might also want to reduce my journey time by one hour or less. minutes spent in transit getting from a to b. We then often have to layer on top of that objective function a set of constraints, sometimes empty, that we have to obey. So maybe the fastest way to get from New York to Boston is to take a plane, but maybe it's not the best way to do it. It's a trade-off between speed and efficiency. We don't know the answer, but we can try to figure out how to make it faster. I only have $100 to spend. So that option is off the table. Or maybe I have to be in Boston before 5:00 PM and while the bus would get me there for $15, it won't. So I have the constraints there on the amount of money I can spend. I can't afford to spend $100 on a trip to Boston. I don't have that kind of money. I'm going to have to spend it on other things. That's what I'm doing. get me there before 5:00. And so maybe what I'm left with is driving, something like that. So objective function, something you're either minimizing or maximizing, and a set of constraints that eliminate some solutions. And as we'll see, there's an asymmetry here. We handle these two things differently. We don't have the same set of solutions. We can't do the same thing all the time. We need to find a way to do it all at once. use these things all the time. I commute to work using Waze, which essentially is solving-- not very well, I believe-- an optimization problem to minimize my time from home to here. When you travel, maybe you log into various advisory programs that try and optimize things for you. They're not perfect, but they're a good starting point for thinking about what you want to do when you're on the road, and how you can get there in the most efficient way possible. all over the place. Today you really can't avoid using optimization algorithm as you get through life. Let's talk about a specific optimization problem called the knapsack problem. The first time I talked about the knapack problem I neglected to show a picture of a knapacks. I'm sorry, I didn't mean to do that, I was just thinking of a specific problem that I wanted to talk about, and it's a good example of an optimization problem that can be solved with an algorithm. A knapsack is what we old people used to call a backpack, and they used to look more like that than they look today. So the knapsacks problem involves-- usually it's told in a book -- telling people what a knapsak is. It's what a backpack is supposed to look like, and how it's used to be used to carry things. The book is called "Knapsack: The Story of a Backpack" and is published by Simon & Schuster. terms of a burglar who breaks into a house and wants to steal a bunch of stuff but has a knapsack that will only hold a finite amount of stuff that he or she wishes to steal. And so the burglar has to solve the optimization problem of stealing the items in the knapsacks. The burglar must solve the problem of finding a way to get all the items that he wants in a small amount of time. The problem can be solved by solving the following equation: stuff with the most value while obeying the constraint that it all has to fit in the knapsack. So we have an objective function. I'll get the most for this when I fence it. And a constraint, it has to fits in my backpack. And you can guess which of these items is the most valuable to me. I'm going to fence it with a fence, and it will be the most useful to me in the long run. I hope you'll join me. these might be the most valuable items here. So here is in words, written words what I just said orally. There's more stuff than you can carry, and you have to choose which stuff to take and which to leave behind. I should point out that there are two variants of this story. There are two versions of the story that you can read on CNN.com/soulmatestories. For more information on the book, go to: http://www.cnn.co.uk/2013/01/29/book/book-of-the-year/bookoftheyear-2013/index.html. The 0/1 knapsack problem means you either take the object or you don't. So maybe if I take in my gold bar and shaved it into gold dust, I then can say, well, the whole thing won't fit in, but I can fit in a path, part of it. The continuous or so-called fractional knapsacks problem says I can take pieces of it, for example. Of course, you can't take the whole gold bar, but you can take some of it or parts of it and so on. really boring. It's easy to solve. How do you think you would solve the continuous problem? Suppose you had over here a pile of gold. And you wanted to maximize your value, and you'd fill up your knapsack with gold. Well, you'd filled upyour knapsacks with gold and silver and raisins. And if you had a whole lot of gold, you would fill it up with gold, silver and silver. You'd fill it all up. You wouldn't need any more gold. until you either ran out of gold or ran out. of space. If you haven't run out of space, you'll now put silver in until you run out. Of course, if you still haven't ran out, well, then you'll take as many raisins as you can fit in. And so on and so on until you've reached the end of the game. And if you have, you've now reached the top of the leaderboard. And you'll be able to see the rest of the world from the top. But you can solve it with what's called a greedy algorithm, and we'll talk much more about this as we go forward. Where you take the best thing first as long as you can and then you move on to the next thing. As we'll see, the 0/1 knapsack problem is a good example of this type of algorithm. And it can be used to solve other problems as well, such as the 2/2/2 problem or the 3/3/3 problem. is much more complicated because once you make a decision, it will affect the future decisions. Let's look at an example, and I should probably warn you, if you're hungry, this is not going to be a fun lecture. So here is my least favorite because I always want to. Because I always. want to say, 'I'm going to do this because I want to be able to do it.' And I always do it because I like to make people feel good about themselves. eat more than I'm supposed to eat. So the point is typically knapsack problems are not physical knapsacks but some conceptual idea. So let's say that I'm allowed 1,500 calories of food, and these are my options. I have to go about deciding, looking at this food-- and it's interesting, says CNN's John Sutter. Sutter: "It's interesting to think about how you're going to carry all of that food around with you" again, there's things showing up on your screen that are not showing on my screen, but they're harmless, things like how my mouse works. Anyway, so I'm trying to take some fraction of this food, and it can't add up to more than 1,500 calories. The problem might be that I'm not taking enough calories to make it all the way through the food. So I'm going to have to cut it in half, and then cut it into smaller pieces. that once I take something that's 1,485 calories, I can't take anything else, or maybe 1,200 calories and everything else is more than 300. Once I take one thing, it constrains possible solutions. A greedy algorithm, as we'll see, is not guaranteed to give me the best answer. Let's see what happens when we try a greedy algorithm with more than 1,500 calories in a serving. We'll see if we get a good answer. The answer is not likely to be good. look at a formalization of it. So each item is represented by a pair, the value of the item and the weight of the items. And let's assume the knapsack can accommodate items with the total weight of no more than w. I apologize for the short variable names, but it's the only way I can think of to represent the items in such a way that they can be carried in a knapsacks. I'm not a mathematician, but I think it's a good way to go. they're easier to fit on a slide. Finally, we're going to have a vector l of length n representing the set of available items. This is assuming we have n items to choose from. So each element of the vector represents an item. So those are the items we have. And we have a set of n items that we can choose from, and so on. We can then choose which of these items we want to use for the slide. And that's what we do. A binary number is used to represent the set of items I choose to take. For item three say, if bit three is zero I'm not taking the item. And then another vector v is going to indicate whether or not an item was taken. So essentially I'm going to use a binary number to represent a set ofItems. If bit two is zero, I'm taking that item. If I take bit three, it means I've taken that item, and if it's not, I've not taken it. bit three is one, then I am taking the item. So it just shows I can now very nicely represent what I've done by a single vector of zeros and ones. Let me pause for a second. Does anyone have any questions about this setup? It's important to get this right. It's very easy to do. It just shows you can do it with a single set of vectors. It doesn't mean it's perfect, but it means it's easy to get it right. setup because what we're going to see now depends upon that setting in your head. So I've kind of used mathematics to describe the backpack problem. And that's typically the way we deal with these optimization problems. We start with some informal description, and then we translate them into a more formal one. So that's what we've done in this case. We've used math to describe a backpack problem, then we've translated it into a formal problem. That's how we work with optimization. mathematical representation. We're going to try and find a vector v that maximizes the sum of V sub i times I sub i. Now, remember I subi is the value of the item. V subi can be either zero or one. So if I didn't, if the item was zero, it would be one. If it was one, it wouldn't be zero. It would be either one or zero. If the item is one, then it is one. take the item, I'm multiplying its value by zero. So it contributes nothing to the sum. If I did take the item,. I'm multiply its. value by one. So the value of the item gets added to the. sum. So that tells me the. value of V. And I want to know how much V. would be if I took the item and multiplied it by one to get V. I want V. to be the same as the amount of money I would have taken if I had taken the item. to get the most valuable V I can get subject to the constraint that if I look at the item's dot weight and multiply it by V, the sum of the weights is no greater than w. So I'm playing the same trick with the values of multiplying each one. To get the best V, I can multiply each item by V and then divide by w to get the total number of dot weights I need to multiply by V. For example, I'm multiplying V by w and then dividing by V to get a total of V. by zero or one, and that's my constraint. Make sense? All right, so now we have the problem formalized. How do we solve it? Well, the most obvious solution is brute force. I enumerate all possible combinations of items; that is to say, I generate all subsets of the items. And that's how I solve the problem. It's a very simple problem, but it can take a long time to solve if you know how to do it. that are available-- I don't know why it says subjects here, but we should have said items. This is called the power set. The power set of a set includes the empty subset. It includes the set that includes everything and everything in between. So the powerSet is the set of all the sets in a set that are available to the user. That's what the PowerSet is. It's the set where the user can choose what they want to do with their data. subsets of size one, subsets of size two, et cetera. So now I've generated all possible sets of items. I can now go through and sum up the weights and remove all those sets that weigh more than I'm allowed. And then from the remaining combinations, choose any one whose size one or two is the same as the one in the previous set. And so on and so on until I've gone through all the possible sets and removed all the sets that are too big. value is the largest. I say choose any one because there could be ties, in which case I don't care which I choose. So it's pretty obvious that this is going to give you a correct answer. You're considering all possibilities and choosing a winner. Unfortunately, it's usually not very very good at picking a winning answer. It's usually a very, very bad choice. It could be a very good one, but it's probably a very bad one. It might be a good one if you're really good at it. "Not very practical, right, even for a fast computer generating that many possibilities is going to take a rather long time. So kind of disappointing. What we see here is that's what the power set is if you have 100. vec.practical. We look at it and say, well, we. say, 'Well, we're not going to be able to do that,' " he says. "It's a bit of a shame, but it's not very practical." got a brute force algorithm. It will solve the problem, but it'll take too long. We can't actually do it. 100 is a pretty small number, right. We often end up solving optimization problems where n is something closer to 1,000, sometimes even a million. Clearly, brute force isn't going to solve this problem. It's going to take a lot more time than we think to get to the end of the problem. And it's not going to be easy. Are we just being stupid? Is there a better algorithm that I should have showed you? I shouldn't say we. Am I just being Stupid? The sad answer to that is yes, I am being stupid. I'm being stupid because I don't know how to make an algorithm that works. And I'm not sure I want to know how an algorithm works. I just want to make it work. I want it to make me feel better about myself. That's what I'm trying to do. is no for the knapsack problem. And indeed many optimization problems are inherently exponential. There is no algorithm that provides an exact solution to this problem whose worst case running time is not exponential in the number of items. It is an exponentially hard problem. There are no algorithms that provide an exact Solution to the Knapsack Problem. There. is no solution to theknapsackproblem that provides a solution that is exact for all knapsacks. It. is an exponential hard problem with a worst-case running time. is no really good solution. But that should not make you sad because while there's no perfect solution, we're going to look at a couple of really very good solutions that will make this poor woman a happier person. So let's start with the greedy algorithm. I already talked to the algorithm, but I want to talk to you about the other side of it as well. You can watch the rest of the interview on CNN iReport on Sunday at 10pm ET. Click here to watch the full interview. you about greedy algorithms. We say while the knapsack is not full, put the best available item into theknapsack. When it's full, we're done. You do need to ask a question. What does best mean? Is the best item the most valuable? Is it more valuable than the other items in the knapack? We say it could hardly be simpler. It's time to get the best out of your knapacks and get to work. We're looking forward to hearing from you. it the least expensive in terms of, say, the fewest calories, in my case? Or is it the highest ratio of value to units? Now, maybe I think a calorie in a glass of beer is worth more than a calories in a bar of chocolate, maybe vice versa. Which do you think is the most expensive? Let us know in the comments below or on Twitter @CNNOpinion. Back to Mail Online home. back to the page you came from.. gets me to a concrete example. So you're about to sit down to a meal. You know how much you value the various different foods. For example, maybe you like donuts more than you like apples. You have a calorie budget, and here we're going to have a fairly austere meal. We're not going to be talking about how many calories you have, but how much of them you have. We'll be looking at the calorie budget and the amount of food you have left. budget-- it's only one meal; it's not the whole day-- of 750 calories. They should probably have a knapsack solver at every McDonald's and Burger King. That is as we've seen aknapsack problem. So here's the solution: We'll have to go through menus and choose what to eat. We'll be back next week with the next installment of "This Is Life with Lisa Ling" on CNN iReport. Back to the page you came from. a menu I just made up of wine, beer, pizza, burger, fries, Coke, apples, and a donut, and the value I might place on each of these and the number of calories. And we're going to build a program that will find an accurate list of what's in each of those items, and how many calories there are in them. We'll post the results on CNN.com/Heroes on Monday at 8 p.m. ET. For more, go to CNN.co/heroes. optimal menu. And if you don't like this menu, you can run the program and change the values to be whatever you like. Well, as you saw if you took 60001, we like to start with an abstract data type, like to organize our program around data abstractions. So I've been trying to create a program that looks like a data type. I've tried to make it look a little bit like a database, but it's not quite there yet. I'm trying to get it to look a bit more like a table. got this class food. I have a getValue, a getCost, density, which is going to be the value divided by the cost, and then a string representation. So nothing here that you should not all be very familiar with. Then I'm going to have a function. I can initialize things. I've got a get value, get cost, get density, and get string representation, so I can get the value and the cost of the function. So I have to get a value and a cost to get the density. called buildMenu, which will take in a list of names and a list. of values of equal length. They're all the same length. And it will build the menu. So it's going to be a menu of tuples. And I build each food by giving it its name, its value, and its caloric content. Now I have a menu. Now comes the fun part. Here is an implementation of a greedy algorithm. I called it a flexible greedy primarily because of this key function over here. red there's a parameter called keyfunction. That's going to be-- map the elements of items to numbers. So it will be used to sort the items. So I want to sort them from best to worst, and this function will beUsed to tell me what I mean by best. Red is an open-source, free-to-use, cross-platform programming language. It was developed by the Software Development Center at the University of California, Los Angeles, and is available on GitHub. So maybe keyfunction will just return the value or maybe it will return the weight. But the idea here is I want to use one greedy algorithm independently of my definition of best. So I use keyfunction to define what I want the algorithm to do. The result is a greedy algorithm that can be used to find the best value for a given value. For example, it could return a function of the density, or a value of the weight, or some other function of density. It could also return a value or a weight function, or any other function. I mean by best. I'm going to sort it from best to worst. And then for i in range len of items sub copy-- I'm being good. I've copied it. That's why you sorted rather than sort. I don't want to have a side. I just want to get it out of the way. And that's what I'm doing. I want it to go away. It's time to get on with my life. And I'm not going to let it go to waste. effect in the parameter. In general, it's not good hygiene to do that. And so for-- I'll go through it in order from best to worst. And if the value is less than the maximum cost, if putting it in would keep me under the cost or not over the cost, I'll put it in. But if it's more than that, I'm not going to do it. I don't think it's a good idea to put it into the parameters. cost, I put it in, and I just do that until I can't put anything else in. So I might skip a few because I might get to the point where there's only a few calories left, and the next best item is over that budget. But maybe further down, I might not be able to do that. I might have to cut back on some of the things I'm doing. I don't know. I'm just going to do what I feel like doing at the time. I'll find one that is not over it and put it in. That's why I can't exit as soon as I reach. And then I'll just return. Does this make sense? Does anyone have any doubts about whether this algorithm is working? If you do, please email CNN iReport at jennifer.smith@dailymail.co.uk and we'll feature the best in our weekly Newsquiz. Back to Mail Online home. back to the page you came from. actually works? I hope not because I think it does work. Let's ask the next question. How efficient do we think it is? What is the efficiency of this algorithm? Let's see where the time goes. That's the algorithm we just looked at. So I deleted the comment, so we'd be able to see where we'd go with it. So we'd see where it goes. So that's what we're going to do now. We'll see what happens. have a little more room in the slide. Who wants to make a guess? By the way, this is the question. So please go answer the questions. We'll see how people do. But we can think about it as well together. Well, let's see where the time goes. The first question is: What is the first thing you do when you wake up in the morning? The answer is: I don't know. I go to the bathroom. The second question is, what is your first thing when you get out of the shower? The response is, "I don’t know." thing is at the sort. So I'm going to sort all the items. Python uses something called timsort, which is a variant of something called quicksort, which has the same worst-case complexity as merge sort. And we heard from Professor Grimson how long the sort takes. See who remembers. See how long it takes to sort an item in Python. See what it looks like when you sort an object in Python, and how it looks in the editor. See it in action. so we know that is n log n where n in this case would be the len of items. So we know we have that. Then we have a loop. How many times do we go through this loop? Well, we gothrough the loop n times, once for each. Once for each item, that is a loop of n times. So, we have to go through the loop a number of times to get the total number of items in the loop. That is n. item because we do end up looking at every item. And if we know that, what's the order? AUDIENCE: [INAUDIBLE]. JOHN GUTTAG: N log n plus n-- I guess is order n log n, right? So it's pretty efficient. And we can do this for big numbers like a million. And it's a pretty efficient way to look at a million items. It's a lot of work, but it's very, very efficient. Log of a million times a million is not a very big number. So it's very efficient. Here's some code that uses greedy. Takes in the items, the constraint, in this case will be the weight, and just calls greedy, but with the keyfunction and prints what we have. So this is a very efficient way to get a log of the number of items that are in the key. This is a simple example of how greedy can be used to do this. we're going to test greedy. I actually think I used 750 in the code, but we can use 800. And here's something we haven't seen before. So used greedy by value to allocate and calls testGreedy with food, maxUnits and Food.getValue. Notice it's passing the function. That's what we want to do with greedy. We want to use greedy to test the allocation of food. We need to test that greedy allocates the right number of units. why it's not-- no closed parentheses after it. Used greedy to allocate. And then we have something pretty interesting. What's going on with this lambdas? So here we're going to be using greedy by density to allocate-- actually, sorry, this is greedy by cost. And you'll notice what we're doing. We're using greedy to allocate. And we're using cost to allocate, which is a different type of greedy. So we're actually using greedy for cost. is-- we don't want to pass in the cost, right, because we really want the opposite of the cost. We want to reverse the sort because we want the cheaper items to get chosen first. The ones that have fewer calories, not the one that has more calories. As it is now, we have to pay more for our food. We have to spend more on our health. We need to eat healthily. We can't afford to eat more calories if we're paying more for food. happens, when I define cost, I defined it in the obvious way, the total number of calories. So I could have gone and written another function to do it, but since it was so simple, I decided toDo it in line. So let's talk about Lambda and then come back to the topic of cost and calories. We'll talk about cost, calories, calories and calories again in the next episode of The Daily Discussion, which airs on Monday, November 14, at 10am ET. Lambda is used to create an anonymous function, anonymous in the sense that it has no name. So you start with the keyword Lambda. You then give it a sequence of identifiers and then some expression. What Lambda does is it builds a function that evaluates that. Back to Mail Online home.back to the page you came from. Click here to read the full transcript of this article. To read the rest of the interview, click here. To listen to the full interview, Click here. expression on those parameters and returns the result of evaluating the expression. So instead of writing def, I have inline defined a function. So if we go back to it here, you can see that what I've done is lambda x one divided by Food.getCost of x. Notice food is food is the amount of money you have to spend to buy the item you're trying to buy. The result is the price you pay for the product you want to buy with the money you get from the purchase. the class name here. So I'm taking the function getCost from the class food, and I'm passing it the parameter x, which is going to be what? What's the type of x going to being? I can wait you out. What is the type the x have to be for? I don't know. I'm going to take a guess. The type of the x has to be the class name. The class name is the name of the function. The function getsCost is the function that gets the cost of the food. this lambda expression to make sense? Well, go back to the class food. What's the type of the argument of getCost? That's an easier question. We'll go back and we'll look at it. What is the name of the arguments to getCost, and what is the kind of argument to get cost? We'll take a look at that later. We're going to go to the next part of the show, where we'll talk about the definition of get cost. Food. We do have a tradition in this class that people who answer questions correctly get rewarded with food. Oh, Napoli would have caught that. So it has to be of type food because it's self in the class. Thank you. JOHN GUTTAG: Food. We'll see you in class next week. Back to the page you came from. Back from the pageyou came from, back to thepage you were from.Back to the pages you camefrom. Back into the page. class food. So if we go back to here, this x has to be of type food, right. And sure enough, when we use it, it will be. Let's now use it. I should point out that Lambda can be really handy as it is here, and it's possible to use it in a number of ways. For example, it can be used to create a list of all the types of food that are of the same type. It can also be used in other ways to create lists of different types. write amazing, beautiful, complicated Lambda expressions. And back in the good old days of 6001 people learned to do that. And then they learned that they shouldn't. My view on lambda expressions is if I can't fit it in a single line, I just go right def and write a lambdas expression. That's how I write my code. I don't worry about how many lines it takes. I just write a Lambda expression and call it a Lambdas Expression. function definition because it's easier to debug. But for one-liners, Lambda is great. Let's look at using greedy. So here's this function testGreedy, takes foods and the maximum number of units. And it's going to go through and it will test all three greedy algorithms. And we just saw the greedy algorithm that we were going to use. We just saw that greedy is a greedy function definition. So let's use greedy to test the greedy algorithms that we are using. This is just the menu we saw. I'm going to build the menus, and then I am going to call testGreedys.that. And so I picked up some names and the values. And then here is the call of it. So let's go look at the code that does this. So this is the menu. This is the menus. This was the menu that we saw, and this was the menus we saw that we could use to test the code. That's the code we used. Here's the code. It's all the code we just need. Keep changes. Here you have it or maybe you don't, because every time I switch applications Windows decides I don't want to show you the screen anyway. This really shouldn't be necessary. Why it keeps forgetting, I don’t know. Anyway, so here's theCode. It’s all thecode we just needs. Keep Changes. Here’S the code for the code that we just needed.keep changes. looked at. Now let's run it. Well, what we see here is that we use greedy by value to allocate 750 calories, and it chooses a burger, the pizza, and the wine for a total of 284 happiness points. On the other hand, if we used greedy by cost, I get 318 happiness points and a different menu, the apple, the wine, the cola, the beer, and a donut. I guess this is what I signed up for when I put my preferences on. solution with 318, apple, wine-- yeah, all right. So I actually got the same solution, but it just found them in a different order. Because the sort order was different because in this case I was sorting by density. From this, from this, we can get the solution for 318, Apple, Wine. The solution is: 318, apples, wine, wine. That's the same as 318, Wine, Apple. The problem is that the solution is different because it is sorted by density, which is different. The problem is that a greedy algorithm makes a sequence of local optimizations, chooses the locally optimal answer at every point, and that doesn't necessarily necessarily mean the best answer. We see an important point about greedy algorithms, right, that we used the algorithm and we got different answers. Why do we have different answers? The answer is that greedy algorithms don't always get the best answers. The answer to that question is that they don't necessarily get the right answer. That's the problem with greedy algorithms. add up to a globally optimal answer. This is often illustrated by showing an example of, say, hill climbing. So imagine you're in a terrain that looks something like this, and you want to get to the highest point you can get. So you might choose as a greedy algorithm to get there as quickly as possible. The algorithm will then try to find the best way to get from that point to the top of the mountain. It will try to do this in a variety of ways to get the best possible answer. if you can go up, go up; if you can't go up,. you stop. So whenever you get a choice, you go up. And so if I start here, I could right in the middle maybe say, all right, it's not up but it't not down either. So I'll go. I could say, 'All right. It's not down but it's also not up either,' and I'd go. So that's what I'm going to do. either left or right. And let's say I go right, so I come to here. Then I'll just make my way up to the top of the hill, making a locally optimal decision head up at each point. And I'll get here and I'll say, well, now any place I go, I'm going to go to the left or the right. That's what I'll do. I'll make a local optimal decision and head to the right or the left. go takes me to a lower point. So I don't want to do it, right, because the greedy algorithm says never go backwards. On the other hand, if I had gone here for my first step, then my next step up would take me up. And that's the problem with greedy algorithms, and that's what I would find is I'm at a local maximum rather than a global maximum. I'm here and I'm happy. But I'd get to here, and I'd stop and say, OK, no way to go but down. that you can get stuck at a local optimal point and not get to the best one. Now, we could ask the question, can I just say don't worry about a density will always get me the best answer? Well, I've tried a different experiment. Let's say I'm feeling expansive and I want to get to a point where I can see across the whole of the city. I can get to that point by looking across the city and looking at the city at a time. I'm going to look at the whole city and try to see where the best point is. and I'm going to allow myself 1,000 calories. Well, here what we see is the winner will be greedy by value, happens to find a better answer, 424 instead of 413. So there is no way to know in advance. Sometimes this definition of best might work. Sometimes that might. Sometimes it doesn't, and that's what we're going to find out in the next few days. We'll see how it works out for the winner of this week's game. work. Sometimes no definition of best will work, and you can't get to a good solution. On Wednesday, we'll talk about how do you actually guarantee finding an optimal solution in a better way. We'll also look at how to get to the optimal solution with a greedy algorithm, and how to do it in a more efficient way. Back to Mail Online home. Back To the page you came from."How do you find the best solution for a problem?" you ask. way than brute force. See you then. Back to the page you came from. We'll see you in a few weeks. We've got a long way to go, but we'll be in touch again soon. We're looking forward to seeing you again. We hope to see you at the next one. We love you, too. We miss you. We will see you soon. Back on the page we go. We’ll see you next week. Back in the next page.