John Guttag: This is the 60002 course, the second half of 600. The main topic of the course is what I think of as computational models. How do we use computation to understand the world in which we live? What is a model? To me, it's an experimental device that can help us understand something that has happened, to build a model that explains phenomena we see every day, or to predict the future, something that hasn't happened. The course is really less about programming and more about dipping your toe into the exotic world of data science. with an objective function that's either to be maximized or minimized. We then often have to layer on top of that objective function a set of constraints, sometimes empty, that we have to obey. So for, example, if I'm going from New York to Boston, I might want to find a route by car or plane or train that minimizes the total travel time. We use these things all the time. I commute to work using Waze, which essentially is solving-- not very well, I believe-- an optimization problem to minimize my time. and I'm going to allow myself 1,000 calories. Well, here what we see is the winner will be greedy by value, happens to find a better answer, 424 instead of 413. So there is no way to know in advance. Sometimes this definition of best might work. Sometimes no definition ofbest will work. You can't get to an optimal solution with a greedy algorithm. On Wednesday, we'll talk about how do you actually guarantee finding an optimal Solution in a better way than brute force. Python uses something called timsort, which is a variant of something called quicksort. timsort has the same worst-case complexity as merge sort. Python uses a sort algorithm called merge sort, which uses a different algorithm called sort. The sort algorithm has a power set of 100. The power set is if you have 100 Vec.value is the largest. So it's pretty obvious that this is going to give you a correct answer. You're considering all possibilities and choosing a winner, but it's usually not very practical.