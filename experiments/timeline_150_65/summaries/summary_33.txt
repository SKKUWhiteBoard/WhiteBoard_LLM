The 60002 course is the second half of the 600 program. The goal of the course is to improve your skills as a programmer. There is a lot more conceptual, algorithmic material in 60002 than in 600. The course is offered free of charge to students at MIT. For more information about MIT OpenCourseWare, visit ocw.mit.edu. Your support will help MIT Open courseWare continue to offer high quality educational resources for free. To make a donation or to view additional materials from hundreds of MIT courses, visit MIT Open CourseWare at ocW. The course is really less about programming and more about dipping your toe into the exotic world of data science. The lectures will be-- and maybe I'm speaking euphemistically-- a bit faster paced. The assignments are going to be a bit easier, at least that's what students have reported in the past, because they'll be more focused on the problem to be solved than on the actual programming. Today, for example, we'll talk about Lambda abstraction. Inevitably, some comments about software engineering, how to structure software engineering. The main topic of the course is what I think of as computational models. How do we use computation to understand the world in which we live? What is a model? To me, it's an experimental device that can help us to either understand something that has happened or build a model that explains phenomena we see every day. Hopefully it will go a little bit smoother than in the last problem set in 60001. More emphasis in using packages.your code, more emphasis in use packages. Science is moving out of the wet lab and into the computer. Increasingly, there is an increasing reliance on computation rather than traditional experimentation. We'll talk about three kinds of models-- optimization models, statistical models, and simulation models. An optimization model is a very simple thing. We start with an optimization model and then go on to other types of models, such as statistical models or simulation models, which can be used to predict the future of a given area of science. For example, a climate change model. We can build models that sort of explain how the climate has changed over the millennia. with an objective function that's either to be maximized or minimized. We then often have to layer on top of that objective function a set of constraints, sometimes empty, that we have to obey. So maybe the fastest way to get from New York to Boston is to take a plane, but I only have $100 to spend. So I have the constraints there on the amount of money I can spend. And as we'll see, there's an asymmetry here. We handle these two things differently. The burglar has to solve the optimization problem of stealing the stuff with the most value while obeying the constraint that it all has to fit in the knapsack. So we have an objective function. I'll get the most for this when I fence it. And a constraint, it has tofit in my backpack. And you can guess which of the two of those is the burglar's solution. The burglar is the one who gets the most money from the fence. The thief is the person who gets to fence the most of the stuff. The 0/1 knapsack problem means you either take the object or you don't. You can solve it with what's called a greedy algorithm, and we'll talk much more about this as we go forward. These might be the most valuable items here. So here is in words, written words what I just said orally. There's more stuff than you can carry, and you have to choose which stuff to take and which to leave behind. I should point out that there are two variants of it. is much more complicated because once you make a decision, it will affect the future decisions. Let's look at an example, and I should probably warn you, if you're hungry, this is not going to be a fun lecture. So here is my least favorite because I always want to eat more than I'm supposed to eat. So the point is typically knapsack problems are not physical knapsacks but some conceptual idea. So once I take one thing, it constrains possible solutions. A greedy algorithm, as we'll see, is not guaranteed to give me the best answer. A binary number is going to represent the set of items I choose to take. For item three say, if bit three is zero I'm not taking the item. If bit 3 is one, then I am taking theitem. So it just shows I can now very nicely represent what I've done by a single vector of zeros and ones. Does anyone have any questions about this setup? It's important to get this setup because what we're going to see now depends upon that setting in your head. mathematical representation. We're going to try and find a vector v that maximizes the sum of V sub i times I sub i. I want to get the most valuable V I can get subject to the constraint that if I look at the item's dot weight and multiply it by V, theSum of the weights is no greater than w. So I'm playing the same trick with the values of multiplying each one. So that tells me the value of V. And I'm trying to get a value that maximises the sum. The most obvious solution is brute force. I enumerate all possible combinations of items; that is to say, I generate all subsets of the items that are available. So now I've generated all possible sets of items. I can now go through and sum up the weights and remove all those sets that weigh more than I'm allowed. And then from the remaining combinations, choose any one whose.by zero or one, and that's my constraint. Make sense? All right, so now we have the problem formalized. The power set is if you have 100 Vec.value is the largest. Even for a fast computer generating that many possibilities is going to take a rather long time. We often end up solving optimization problems where n is something closer to 1,000, sometimes even a million. Clearly, brute force isn't going to go as far as we'd like, so it's kind of disappointing. We look at it and say, well, we got a brute force algorithm. It will solve the problem, but it'll take too long. We can't actually do it. There is no algorithm that provides an exact solution to this problem whose worst case running time is not exponential in the number of items. But that should not make you sad because while there's no perfect solution, we're going to look at a couple of really very good solutions that will make this poor woman a happier person. So let's start with the greedy algorithm. It is an exponentially hard problem. There is no really good solution. I shouldn't say we. Am I just being stupid? Is there a better algorithm that would have given us the answer? you about greedy algorithms. We say while the knapsack is not full, put the best available item into the knapack. When it's full, we're done. You do need to ask a question. What does best mean? Is the best item the most valuable? Is it the least expensive in terms of, say, the fewest calories, in my case? Or is it the highest ratio of value to units? Maybe I think a calorie in a glass of beer is worth more than a calories in a bar of chocolate. red there's a parameter called keyfunction. That's going to be-- map the elements of items to numbers. So it will be used to sort the items. So I want to sort them from best to worst, and this function will beused to tell me what I mean by best. So maybe keyfunction will just return the value or maybe it will return the weight. But the idea here is I want. to use one greedy algorithm independently of my definition of best. And then for i in range len of items sub copy-- I'm being good. effect in the parameter. In general, it's not good hygiene to do that. So for-- I'll go through it in order from best to worst. And if the value is less than the maximum cost, if putting it in would keep me under the cost or not over the cost, I put it in. And I just do that until I can't put anything else in. So I might skip a few because I might get to the point where there's only a few calories left. actually works? I hope not because I think it does work. Let's ask the next question. How efficient do we think it is? What is the efficiency of this algorithm? Let's see where the time goes. So I deleted the comment, so we'd have a little more room in the slide. Who wants to make a guess? By the way, this is the question. So please go answer it. We'll see how people do. But we can think about it as well together. See who remembers. so we know that is n log n where n in this case would be the len of items. So we know we have that. Then we have a loop. How many times do we go through this loop? Well, we gothrough the loop n times, once for each item because we do end up looking at every item. So it's pretty efficient. And we can do this for big numbers like a million. Log of a million times a million is not a very big number. we're going to test greedy. I actually think I used 750 in the code, but we can use 800. It doesn't matter. And here's something we haven't seen before. So used greedy by value to allocate and calls testGreedy with food, maxUnits and Food.getValue. Notice it's passing the function. That's why it's not-- no closed parentheses after it. Used greedy to allocate. And then we have something pretty interesting. What's going on with this lambda? Lambda is used to create an anonymous function, anonymous in the sense that it has no name. What Lambda does is it builds a function that evaluates that expression on those parameters and returns the result of evaluating the expression. So instead of writing def, I have inline defined a function. So if we go back to it here, you can see that what I've done is Lambda x one divided by Food.getCost of x. Notice food is food is the total number of calories. the class name here. So I'm taking the function getCost from the class food, and I'm passing it the parameter x, which is going to be what? What's the type of the argument to getCost? We'll go back and we'll look at it. So it has to be of type food because it's self in the class. Oh, Napoli would have caught that. So we do have a tradition in this class that people who answer questions correctly get rewarded with food. Lambda can be really handy as it is here, and it's possible to write amazing, beautiful, complicated lambda expressions. Back in the good old days of 6001 people learned to do that. And then they learned that they shouldn't. My view on lambda expressions is if I can't fit it in a single line, I just go right def and write a function definition because it's easier to debug. But for one-liners, Lambda is great. Let's look at using greedy. TestGreedys.that, and then here is the call of it. It chooses a burger, the pizza, and the wine for a total of-- a value of 284 happiness points, if you will. Well, what we see here is that we use greedy by value to allocate 750 calories. On the other hand, if we say, "Let's try a burger and a pizza," we get 750 calories, and we get 284 points. So let's go look at the code that does this. we use greedy by cost, I get 318 happiness points and a different menu, the apple, the wine, the cola, the beer, and the donut. I've lost the pizza and the burger. And here's another solution with 318, apple, wine-- yeah, all right. So I actually got the same solution, but it just found them in a different order. The problem is that a greedy algorithm makes a sequence of local optimizations, chooses the locally optimal answer at every point. add up to a globally optimal answer. This is often illustrated by showing an example of, say, hill climbing. So you might choose as a greedy algorithm if you can go up, go up. If you can't going up, you stop. So whenever you get a choice, you going up. And so if I start here, I could right in the middle maybe say, all right, it's not up but it'snot down either. So I'll go either left or right. Then I'll just make my way up to the top of the hill, making a locally optimal decision. The problem with greedy algorithms is that you can get stuck at a local optimal point and not get to the best one. Let's say I'm feeling expansive. I don't want to go down. So I'm here and I'm happy. On the other hand, if I had gone here for my first step, then my next step up would take me up, up,. I'd get to here, and I'd stop and say, OK, no way to go but down. I'm done. and I'm going to allow myself 1,000 calories. Well, here what we see is the winner will be greedy by value, happens to find a better answer, 424 instead of 413. So there is no way to know in advance. Sometimes this definition of best might work. Sometimes no definition ofbest will work. You can't get to an optimal solution with a greedy algorithm. On Wednesday, we'll talk about how do you actually guarantee finding an optimal Solution in a better way than brute force.