The following content is provided under a Creative Commons license. Your support will help MIT OpenCourseWare continue to offer high quality educational resources for free. To make a donation, or to view additional materials from hundreds of MIT courses, visit MIT Open CourseWare at ocw.mit.edu. For confidential support call the Samaritans on 08457 90 90 90 or visit a local Samaritans branch, see www.samaritans.org for details. In the U.S. call the National Suicide Prevention Line on 1-800-273-8255. talk about partial differential equations. We're going to have a PDE lecture today. Professor Swan is going to do a review on Friday. There's no lecture on Monday, but you have the quiz, too, Monday night. Wednesday, next Wednesday, we'll be talking about the theory of relativity. We'll be looking at the relationship between relativity and quantum mechanics. And we'll talk about the theories of quantum mechanics and quantum theory, as well as other topics in the next few weeks. week is Veterans Day so it's a holiday. There's no classes at MIT. So the next time I'll be lecturing to you will be a week from Friday. The homework following the quiz will be posted and so you guys can get started on that. That homework involves a COMSOL and it's going to be a big one. I'll post the results a week after the quiz on Friday. For the rest of the week, have fun with the quiz and don't forget to post your own answers. problem which, for those of you who had trouble with COMSOL, might take some extra time, since it's the first time you're doing it. So I would suggest you at least give it a try early. I'm sure the TAs would be very happy to help you to forceCOMSOL on your computer. I've got a couple of tips for you on how to get the most out of your new computer. Click through the video to see what I'm talking about. A partial differential equation is one that has partial derivatives in it. So for example, I have a partial derivative of 1:1:1. Bend COMSOL to your will. To cooperate, use the weekly Newsquiz to test your knowledge of stories you saw on CNN.com or the CNN iReport app. For more, visit the newsquiz.com/newsquiz and the CNN Newsquest app. To test your Knowledgequiz knowledge, try the quiz at the bottom of the page. work a lot on this equation. It's a poor choice, isn't it? OK, so this is the conservation equation for a chemical species in a reacting flow. So the change in the mass fraction of the species z, at a point, xyz at time, t. That differential is given by the differential of the product of mass fraction z and mass fraction xyz, at time t. It is called the conservation equations for chemical species. It can be used to understand the behaviour of chemical compounds in a reaction. a diffusion term, a convection term, and a reaction term. So this is a pretty famous equation. This is part of the Navier-Stokes equations for the whole reactive flow system, which I hope you guys have seen already, and for sure you will see. If you haven't seen them yet, you'll see them soon, I'm sure. I'll show you how to do it in the next few minutes. I'm looking forward to seeing your reaction to it. And there's a lot of other partial differential equations. I work a lot, also, on the Schrodinger equation. That's another partial differential equation. And what's special about thepartial differential equations is that, in this case, this partial derivative is respect to time, holding all the spatial coordinates fixed. And that's what makes it special about Partial differential Equations. It's a very special kind of equation, and it's very difficult to work out, but it can be done. These partial derivatives are respect to space, holding time fixed. A very important thing about partial derivatives, which you probably have encountered in 1040 already, is, it really depends what you hold fixed. And you get different results if you hold different things fixed. Now the implication, when you write these partial derivatives is that time is fixed, and that space is fixed. That's a very important idea. It's the way that the universe works, and the way it works in the universe. an equation like this, is that whatever partials you see-- when I wrote this, if I have this and it has a term that's like d squared, dx squared, is one of the terms in this thing. The convention is, oh boy, I better. This says t, this says x. This say x. this says t. This. says x, this. says t and this. is x. It's the same thing with numbers. It is the same with equations. hold x fixed. And here must be, I must hold t fixed. Because there's another one in the same equation. Now, you can change coordinates however you want. Just really watch out that you carefully follow the rules about what you hold fixed, when you change things. Otherwise you can do anything you want to do with the coordinates you've got at the moment. If you're not careful, you could end up with a whole new set of coordinates that you've never seen before. cause all kinds of craziness. Now you guys probably took multivariable calculus at some point in your distant past. And they told you very carefully what the rules were. So follow them. And I suppose, when you're doing thermo right now? Have you started to do all this partial derivative work? I don't know if you've done it yet, but I'm sure you've got it in your head. If you haven't, you're probably doing it wrong. stuff? Yeah, so you've seen how completely confusing it can be with negative signs showing up all over the place. And other things like this. I don't know if you've encountered this yet? At least, I thought it was confusing when I took it. So just be aware. It's the same with other things, too, like negative signs and other things such as this. You've seen it, you've experienced it. It’s the same thing with other stuff, too. same thing. Now, often you do want to change the equations. So you can write down an equation like this. But, for example, if you have a special symmetry of the problem, like it's cylindrical, for. example, then you might want to changed the cylindrian coordinates. And then you have the same thing. And so you have an equation that is the same as the previous one. But you can change the coordinates if you want to, and that's what we do. to just be careful that you write that correct Laplacian and cylindrical coordinates. Make sure it doesn't mess up anything about what you're holding fixed. Sometimes you might want to be crafty and use some weirdo coordinates. For example, if you wanted to solve the Schrodinger equation for h2 plus, you could use these coordinates instead of the usual ones. For more information on how to write these coordinates, go to: http://www.cnn.com/2013/01/28/science/how-to-write-the-Schrodinger-equation-with-weirdo-coordinates. it turns out there's a special coordinate system called the elliptic coordinate system. And in that coordinate system, the partial differential equation is separable. And so, if you do it in thatcoordinate system, you can actually solve analytical solution, which is pretty unusual for the Schroedinger equation. But it's pretty unusual, too, because it's a new type of equation. It's called an analytical solution. And it can be used to solve complex equations, such as the Euler equation. a pretty goofball coordinate system and you really have to watch out, when you convert, to make sure you do it just right. But it's just the rules, chain rule and the rules about how to keep track of what's being held constant. And when you change, will tell them, to tell them that you've changed the coordinate system, and that they need to pay attention to what's been added or subtracted from the system. It's just a rule, but it's a good one. how, being held constant, how to change it. Now in principle, this problem is like no different than the ODE BBP problems we were just doing. You just have a few more terms. And so, you can use finite element. You can using finite differences. You could use basis set. You have to use finite elements and finite differences to solve the problem. But in principle it's the same thing. It's just a different way of looking at it. And that's what we're going to do. methods. And it's really no different. So all those methods basically look the same. You just get equations that have more unknowns in them. Because, for example, if you're using finite element methods or basis set methods with a local basis set, you need to put points both in the local and the global basis set. It's the same for all of these methods, it's just a different way of looking at them. It doesn't matter what method you use, just the way you look at it. x direction and the y direction, and in this case, the z direction. And then maybe also in the time direction. So now you have a lot of mesh points in all different directions. And so fundamentally, there's no problem, but there's a problem with the way it's done. It's a very complex system, and it's very difficult to get it to work. But it's possible to do it, and I think it's a good way to get the most out of it. in practice, there's a big problem if the number of unknowns gets to be so large. That's the main problem. So think about it. You have some kind of equation like this. It's in three spatial dimensions and in time. How many points do you think you need to discretize? That's what the problem is. How do you get rid of all the unknowns in the equation? That is the big problem. That is what we need to do. We don't want to have to deal with all these unknowns. your solution in the spatial coordinate? There might be somewhere, might be 100, I don't know, points might be enough. So I'll need, well, just in COMSOL, you saw this on Monday. Suppose I just have two dimensions. And so now I have x and y and z. So now I need to have x, y, and z in the coordinate system. And I need a point in that coordinate system, so I need x, Y, and Z. just have x and z. And I start putting points in. Well, I want to have some points along this way. And so, I actually have an unknown here and anunknown here, and one there. And one there and one over there, and so on. And that's what I'm trying to do. I'm not trying to make a point. I just want to make sure that I have points along the way. I don't want to end up with a pointless game. That's not who I am. one there and one there. There's quite a few of them. I think of how many points I have. Each of those is a point where I have a little basis function. And each one of those has a magnitude of how much weight I have on that basis function, he says. He says he has a lot of points that he has to work with, but he doesn't know how many there are. He has to figure out how to get them to work together, he adds. things they called the d's before in the basis functions. And I have a lot of them. Now, it's going to be, if I have 100 points this way, I have 10,000 of these little points. That means I have10,000 unknowns I have to deal with. And that's what I'm going to have to do. I'm not going to get complacent. I am going to try to get the best out of my team. I want to win as much as I can. solve for. 10,000 unknowns are a lot harder to solve for than 100 unknowns. Even with 100unknowns, we were having a lot of trouble, sometimes, to get the real solution. All right? So. So, on some of the problems we did with the ODE BBP problems, even with 100 unknownS, we was having a much more difficult time, sometimes to get a real solution than we thought we would. So. We were having to do a lot more work to solve the problems. you can just see how it just gets to be, like, a big numerical problem. So that's two dimensions. The third dimension, you'll get another 100 times as many points. You might have a million unknowns. And once you get up to a millionunknowns, we're starting to talk serious. We're talking about a serious problem. We'll be talking about it a lot more in the next few weeks, I'm sure. I'm looking forward to it. math, now. OK? Even for your good computers that you have. In addition, it's not just you have the number of mesh points, but it's the. number ofMesh points times the number. of variables at each mesh point. So in the Navier-Stokes equations, what variables do you have? AUDIENCE: What variables are you talking about? What are the mesh points you're trying to work with? What do you mean by "mesh points"? [INAUDIBLE] PROFESSOR: Louder. AUDIENCE: [INAUDIFIED]PROFESSor: Velocity and pressure, OK. We have the different components of velocity. What else we got? Density or temperature. Yeah, temperature maybe, so. So maybe temperature would be what you would like to hear, though. So you have pressure. You have pressure, you have velocity, you've got velocity. You've got pressure. What's the other thing? What else? might use. What else would you have? So then you'd have all these species, right,? The mesh fractions are all the species. So you have, like, y, species one. Mesh fraction, species two. However many you got. So that's a pretty big set of variables and you need to know all these numbers at each point. So this might be-- how many have we've got? One, two, three, four, five, plus however many species we have? you the mesh was what, a million? So maybe I have 10 million unknowns. So the issue, to a large extent, has to do with just, can I solve it? Can I solve a system of 10 millionunknowns? 10 million equations, 10 million knowns. All right, so that's going to be a problem. So that's what we're going to work on. We're not going to get there right away, but we'll get there eventually. to be one big issue. Now the other issues, we still have the same problems we had in ordinary differential equations. We have to worry about actually, is the whole problem even stable to begin with? Physically? Because if it's not stable physically, then probably we're not going to get a stable solution. So you have all those kinds of problems that we had before in the ODE case, and now it's just sort of amplified by the fact, now we have boundary conditions in more than one dimension. multiple chances to screw it up. And we're trying to figure out how to set the boundary conditions correctly. So those are the different kinds of things we have to worry about. But it's all the same problems," he says. "It's all a set of problems that we're all trying to solve at the same time," he adds. "We're all dealing with the same thing at the end of the day. It's just a different way of looking at it," he concludes. you had before, just amplified. Now, because of this problem of the very large number of unknowns, currently, if you have a problem that has two dimensions, you can kind of very routinely solve it. And things like COMSOL on your laptop,. you can usually do those. When you get into a situation like this, it's very difficult to get to the bottom of it. It's very, very hard to find the answer to the question, "How do you solve this problem?" up to three dimensions, you might be able to solve it. And it could be, like, a really big challenge sometimes to solve. And then in reality, we have problems like the Navier-Stokes is four dimensions, right? There's time, as well. There's a long way to go before we can solve all these problems in three dimensions," he says. "There's a lot of work to be done in the next few years to solve these problems," he adds, "but there's time as well" So then that gets to be really hard. The Schrodinger equation has three times the number of electrons dimensions in it. So that gets impossibly hard. And so, specialized methods are developed to handle those systems with a lot of dimensionality. So, like, for the Schrodingers equation, people have to be very, very skilled at dealing with that kind of thing. It's a really, really difficult thing to do, but you can do it. You just have to get better at it. almost always do it with basis set methods. And there's been a huge effort, over decades, to figure out really clever basis sets that are really close to the real solutions, so that you don't need to use too many basis functions to get the good solution. So that's the way to do it. That's the key to it. It's a really clever way of doing it, and it's been around for a long time. And it's very easy to do. It doesn't take a lot of time. way to keep the number of variables down. In the Navier-Stokes world, I'll show you what people do to try to deal with that. There's many other problems. I don't know all the problems in the world. But in general, when you have three or more dimensions in your PDE, that's a problem. That's what I'm going to show you. I'm not going to go into all of them. But that's the way to go. system, you're looking up special tricks. Special ways that are good for that kind of PDE. All right, so I said, one problem was that you could have, that the PDE system, itself, can be intrinsically difficult to deal with. You're looking. up, how do people in this field deal with this particular PDE? You're. looking for ways to get around it. It can be very difficult to get past it, but it can also be very rewarding. Unstable systems can lead to detonation problems. "If I have a system that has some explosive in it, or a mixture of hydrogen and oxygen even, and I have it in a tube or something, if I change my initial conditions, I can go from stable to unstable," he says. "One example I know like that is, detonations problems. So if I have an explosive, or I have some mixture of explosive and oxygen, I have to change the initial conditions" the case where it's stable, that it just sits there, a hydrogen and oxygen. Or it could turn into a regular burning. Or if I change the conditions a little bit differently, it could change into a detonation, where it actually sends a shockwave down the tube faster than the tube is moving. It could send a shock wave down the tubes faster than it is moving, and it could detonate. It's a very, very complex process. It can be very unpredictable. speed of sound, totally different situation. So those kind of systems can be really sensitive to the physical initial conditions. A very small spark can make a really big difference in a system like that. And also, in your numerical solution, if the thing is physically sensitive, it'll typically be. Speed of sound will typically be faster than the speed of sound in a numerical solution. That's a very different situation, and it can be a very big difference. It can be very, very sensitive. sensitive also to numerical noise. If you get numerical noise at some point, that might be enough to kick it over from, say, not igniting at all to having a detonation, which is a completely different solution. But another case, like in biology, if you're trying to study the growth of a plant, you need to be able to hear the noise. That's where the noise comes in. It's a very, very important part of the study of plant growth. of a cell culture or the growth of a tumor, as you know, if somebody has a tumor and one of the cancer cells mutates and does something different, it can have a really different outcome of what happens to the patient. The whole morphology of a cancer cell is very different than that of a cell in a culture or a tumor. It can be very different, and that's what we're trying to figure out. It's a really exciting time to be a cancer patient. can change completely. Everything about it can change. So that's the kind of system, also, that can be very sensitive to small details. A small change in one cell, for example, could be a really big difference. So this is not just in combustion problems you have these kinds of problems. You have these kind of problems as well, and it's not just a combustion problem. It's a whole range of things that can go wrong, and they can all go wrong at once. instabilities. All kinds of problems have this kind of thing. You can have just regular chemical reactors, like in multiple steady states, little tiny fluctuations can make it jump from one steady state to another one. That's another very famous kind of problem. There's another class of PDEs where it's another type of instability. It's called a PDE-like instability, and it's a very serious problem. It can cause a lot of problems, but it can also be a good thing. stable in some sense, but it causes a problem. We call those hyperbolic. And those are like wave equations. The solutions are propagating waves. So the equations of acoustics are wave equations where, basically, a wave propagates more or less without any damping. So what happens, essentially, is that the sound waves get stronger or weaker as they pass through the surface of the surface. The sound waves are like waves, but they are not damped by the surface in any way. then, is you have some numerical noise that will make a little wavelet that will propagate, more or less, without any damping, too. And it'll keep bouncing back and forth inside your domain numerically. And if you keep introducing numerical noise, eventually the whole thing is just full of noise. And that's what we're trying to do here. We're not trying to make noise, we're just trying to get it to behave in a way that makes sense to us. Hyperbolic systems of differential equations need special solution methods. And they set them up a special way. In the numerical method, it's carefully trying to damp out that kind of propagating wave that's coming from the noise. And it doesn't have much relation to the real physical solution. And so they need a special solution method to deal with it. And that's what they do in this case with the 'hyperbolic' method. It's a very special way of dealing with the hyperbolic system. There's a special, whole group of solution methods that people use who are solving acoustics equations and solving electromagnetic equations. If you get into solving shockwave equations-- I actually work for Professor [? Besant? ?] He he's the one who taught me how to solve them. I'm not going to talk about how you solve them in this class, but there's aspecial, wholeGroup of Solution Methods that People Use. If You Get into Solving Shockwave Equations, Click Here. has, like, electrochemical shocks in some of his systems. You have to use special mathematics to correctly handle that, special numerical tricks. But we're not going to get into that in this class. If you get into those things, you should take the class. It's a great subject to learn about, and it's a good subject to study. It really is a must-take class for students of science and math. For more information, go to: http://www.academyofscience.org/. PDE class for hyperbolic equations and they'll tell you just all about the solvers for those kinds of things and special tricks. And there's journal papers all about it. Here, what we're going to focus primarily on two kinds of problems: elliptic problems and parabolic problems. And those problems are elliptic and parabolical. And we'll talk about how to solve them in a way that makes sense to you and your students. We'll also talk about some of the techniques used to solve those problems. ones where there's some dissipation that's very significant. And so, in an elliptic problem, you introduce some numerical noise and as you solve it, the numerical noise kind of goes away. Sort of like intrinsically stable all throughout. Now, the real definition of these things, parabolic, hyperbolic, elliptic, has to be very, very stable. And that's what we're trying to achieve here. We want to make them very stable, and we want them to stay that way. do with flow of information. So in a hyperbolic system, information-- there's regions of the domain that you can make a change here and it doesn't make any effect on some domain part over there. And so that causes-- because that is the real situation, that also propagates into the rest of the system. So that's what we're trying to do here. We're not trying to change the world, we're just trying to make it a little bit better. numerical solution method. So for example, if I'm modeling a shockwave that's moving faster than the speed of sound, I can introduce any pressure fluctuation I want behind the shockwave, and it has no effect on the shock wave. Because the pressure waves from that pressure fluctuated are traveling at the same speed as the shockwaves, it doesn't matter what the fluctuation is. For more information on the method, go to: http://www.sciencemag.org/science/shockwaves/shockwave-solution. speed of sound. They won't catch up to the shock. So they will have no effect whatsoever. So if I was judging what was happening by looking at what's happening in the shock, I can introduce any kind of random noise I want back over, downstream of the shock,. I can. introduce any of the noises I want. Back to Mail Online home. back to the page you came from. Back To the pageyou came from, Back to the site you came From. guess. Yeah? And it won't make any difference at all. And so, that's part of the reason why I need a special kind of solver. If I have elliptic equations, every point affects every other point. A famous case for that is, like, this steady state heat equation. You have you have You have a special solver for that, too, because it's a very complex problem. And you have to know how to solve it, and so on. some temperature source here, a heat source here. And there's some coolness source over here. There's some heat flowing from the hot to the cold. And the heat flow is kind of slow enough that everything sort of affects everything else. Since you actually have, the heat is what's going to affect the rest of the environment, the temperature, the coolness, and the temperature of the room. It's kind of a slow process, but it's a very powerful one. trying to flow by, sort of, every path. And there's some insulation that's resisting its flow. And it has been in the connectivity of flow a certain way. And those kinds of equations are called elliptic. And the methods that we use for the relaxation mesh that we showed are are are elliptic, as well as the methods we used to make the relaxation meshes. The relaxation mesh is a type of mesh that is called an elliptic mesh, which is a kind of mesh. really good for those kinds of methods, for those kind of problems. And then another kind of problem that we get into a lot is like this one. This is called parabolic. And typically, in the cases we see that are parabolic, we have time as part of the problem. We have time to work out how to solve the problem in a way that doesn't cause a lot of damage to the body. That's what we try to do in this case. We don't want to damage the body in any way. Always what we think should happen is that what happens in the future depends on what happened in the past, but not vice versa. So you would expect that when you're computing what's happening at the next time point, it's going to depend on what's happened at earlier time points. We think that's the right way to look at the world, and that's what we're trying to do with the data we have now. We hope that this will lead to a better understanding of the history of the world. But if you try to do it the other way around, it would be kind of weird, right? You wouldn't expect that what in the future really affected stuff in the past. So it naturally leads us to sort of pose it as an ODE IVP, or IVP kind of thing. It's kind of like an IVP in the sense that we're trying to find out what the future is going to be like, and how it's going to affect the present. problem. And we know initially, some time zero something, and we're trying to calculate what happens at some later time. And so those kinds of problems we call parabolic. And the methods that we're going to talk about mostly are ones for solving parabolic and elliptic problems. And you can use these methods to solve parabolic problems, as well as elliptic ones, in your own work. For more information, go to http://www.cnn.com/2013/01/30/science/science-and-technology/parabolic-problem-solving. read, in the middle of chapter 6, has a nice discussion. Just has the mathematical definitions of what these things are. Now, even in a steady state problem, the problem can have a sort of directionality to it. So if you have a problem that's very convective. So you have to be able to find a way of solving it that is convective as well as steady state. And that's a very difficult problem to solve if you're trying to solve a steady-state problem. a flow in a pipe. What's happening downwind is very much affected by what happened upwind, but not vice versa. Say you're burning some hydrogen. You're going to get water vapor made upwind and it's going to flow downwind. If I squirt a little methane in downwind, it doesn't actually do anything to what happenedUpwind. I still have a hydrogen and oxygen flame up there and it’s been burning and making steam. Do you know how to do this? Share your story with CNN iReport. see what I mean? So it has a directionality, even though I might do it as a steady state problem and not have time in it at all. And you've probably already done this, where you can convert, like, a flow reactor. You can write it, sort of, as a as a problem that you might not have the time to solve. So it's a steady-state problem, but it's also a problem with a direction. So you can do it in any way you want. time thing or as a space thing. Time and space are so related by the velocity of the flow. We'll have similar kinds of phenomenon then. It's almost like a parabolic time system. If the flow is fast enough, the fusion backup, anything moving upstream is negligible. It’s all all about the speed of the water. We’re not talking about a time machine here. We're talking about the flow of water. The flow is so fast that the fusion Backup is negligible, if it's fast enough. If it's slow enough, it's all about time. moving from upstream to downstream. And so then, you'll have the same kind of issues. In fact, you may even try to solve it by just starting it at the upstream end and competing stuff and then propagating what that output from that first one does to the next one. That's a good way to try and solve the problem, but it's not a perfect solution. It's not going to solve all of the problems that we have in the software industry. We need to find a way to solve some of them. downstream, and then do them, one at a time. That would be one possible way to try to solve those kinds of problems that are highly convective. As you slow the velocity down, then the diffusion will start to fight the velocity more and more. If you make the velocity lower, the diffusion is less able to fight it. That's one way of trying to solve that kind of problem. It's a very, very complex problem, but it can be solved with a lot of work. very slow, the Peclet number very low, then you really have to worry about things diffusing back upstream. And that would be more like the elliptic problems we have. Because things downstream would actually affect upstream, if the flow is really small. But typically for our problems, the velocity is always really high, and so not much goes from downstream to upstream. It's almost all upstream to downstream. This leads to a famous situation. If you look in the textbook at figures 6.7, 6.8, it's kind of a very different situation. famous problem. That if you just do this problem. So this is just an ODE problem. I just have convection and diffusion, no reaction, very simple. This problem. You'd think that I could just use my finite differences, where I would put, I could use the center difference for this. But I can't do that. So I have to use the convection. And that's a very simple problem. But it's not very easy. It's very, very difficult. here and here and change this into this obvious looking thing. You think that that would be a reasonable thing to do, right? And you can do the same one here. You can write-- I'm terrible with minuses, sorry. So these, the finite difference formulas. And so, you can write these, and so, andso, andSo, and then change them into something that looks like this. And that's what we're going to do here. We're just going to make it more obvious. these like this. This stays equal to zero. And now it's just an algebraic problem to solve. A system of equations, you have equations like this for every value of n. And there's the mesh points. You guys have done this before, yes? Yes. OK, so famous problem is, if if. If. if. if this staysequal to zero, then this stays equal. to zero and so on. And so on and so forth. And this is the solution to the famous problem. you actually try to solve it this way, unless you make delta z really tiny, you get crazy stuff. So on figure 6.7, they actually show what happens for different values of delta z. Different values of what they call the local Peclet number. So there's a thing called delta z and delta z is the number of the delta of a number, and it's a function of the number delta z, which is the size of the value of delta. called local Peclet number, which is-- OK? If you make the local PEClet number too large, actually anywhere bigger than 2, and you try to solve this equation, what you get is oscillations, unphysical oscillations. They'll make the phi go negative. It's crazy. It looks like the simplest equation in the world, but it's actually a very complex one. It has to do with quantum mechanics, and it's a very, very complex thing. the world, right? It's a linear equation, so what's the problem with this? But it doesn't work. And so, then you could think, well, why doesn't it work? And there's, like, multiple ways to explain this about why this doesn't working. I think that the best way to think about it is to think of it as a series of equations. And that's what we're going to try to do in the next few weeks. We'll see how it goes. it is about the information flow. So if the local Peclet number is large, that means that phi is just flowing downwind and diffusion is not doing much. And so, you really shouldn't use this formula to calculate the flow. Because what happens downwind, is not about the flow, it is about what happens in the air. It is about how the air is moving and how fast it is moving. And that's what happens when you have a big Pecel number. at point n plus one, I guess. Here we have the flow this way. So here's n minus one. Here's my point n, n plus 1. I really should not include, is this right, n + 1 in this formula. Hope I have those signs right. I apologize if I do not have them right. It's a long way to go, but I think I've got it most of the way. I'll try to get it right next time. had them backwards. Because I don't think that what happens downstream should really affect this at all. So really, I would do better to change from this center difference formula to what's called the upwind difference formula. Where they would say, OK, instead, let's use phi of n minus, the downwind difference, instead of n plus 1. That would be a better formula. And it would be more accurate. It would be better than what we have now, which is a formula of n + 1. phi of n minus 1 over delta z. Just use that instead of using this formula. Now, you wouldn't think that that would make much difference. But it makes a gigantic difference. And so if you look at figure 6.8 in the textbook, you see you get perfectly stable solutions. You see that you get exactly the same result as if you had used the formula from the textbook. It's the same formula, but you get a much more stable solution. And that's what we're trying to achieve. when you do that. But where you do this one, you get crazy, oscillatory, unphysical solutions, unless you choose delta z really tiny. So I think this is the correct way, the best way to think about it is, it has to be really, really small. And I think that's the way to look at it. I don't think there are any other ways to do it, but I think it's the right way to go about it.” do with information flow. So upwind does not really depend on downwind. If you force it to, by choosing to include that information here, you end up with crazy stuff. So that's one way that you can make your solution depend on stuff that it doesn't really depends on. That's what I'm trying to do with my solution. I'm not trying to make it depend on anything else. I just want it to work the way it's supposed to. I don't want to make things that don't work that way. If you take your delta z too big, then it's too big. Another way to look at it is that, if you really want to compute these derivatives, you've got to keep delta z small. Because we're taking a differential. We're turning it into a finite difference, and if you take it too big you're taking it too far. To see the full transcript of this interview, visit CNN.com/soulmatestories. For the full interview, watch CNN's "Soulmatters" on Sunday, September 16 at 8pm ET. a terrible approximation to do this. And you can look at it. You can see that what we're doing is, when we have this problem where the local Peclet number is getting too large, is we're actually choosing delta z bigger than the, sort of, the thickness of the solution. And it's a terrible approximation. It's a horrible way to solve a problem. It just doesn't work. It doesn't make any sense. It makes no sense. There's no reason to do it. So if you look at the solution, the analytical solution of this problem, it's like this. Where this has a very, very thin layer at the end. It's like the flow has pushed all your stuff to one side. And if you choose your delta z to be from here, that's where it's going to go. That's where the flow is going to take you. And that's what we're trying to get to. We're going to try to get there as soon as possible. to here, that's how big your delta z is, and then you're computing the derivative of this point halfway along from here to where this is. You compute your derivative like that. It's not a very good, not avery accurate representation of what the real derivative is here. And it's a very, very bad way to look at a point in time. And that's what we're trying to do here. We're looking at the past, and we're looking to the future, and that's where we're going. in fact, you really should have a bunch of points here and here. And so you did something really crazy to use a big value of delta z to start with. So that's another way to look at it. It's not just one point, it's a series of points. It could be a set of points, it could be an array. It can be a whole series of different points. And that's what we're trying to do here. We're looking at the sharp edge of the curve. this problem. Now, the fix, by doing this upwind differencing, I think the best way to look at this is saying, well, I'm just going to make sure I only depend, I only make the equations depend on what's upwind, with the convective term. Because there's nothing convecting from downwind. The fix is to make the equation depend on the upwind term, rather than the downwind term. That's the way to fix the problem. So just leave that out. Another way to think about it, which is in the text, is that by doing this, you're introducing another thing called numerical diffusion, where you're actually, effectively increasing the diffusivity. Because this is a very poor way to do it. So that's a conceptual way of thinking about it. And that's the way I'm going to use it in the rest of this article. I'm not going to go into too much detail about how I'm doing it. approximation to the differential. This is a asymmetrical finite difference formula. It's not a very good value estimate of the derivative, if delta z is big. But you can write it out carefully and write this out and say, oh, this actually is sort of like this plus an effective an effective difference formula, if it's not too big. It can be used to get a better estimate of a value of a derivative of a function of a factor of 2 or 3. diffusivity chosen very carefully, so the terms cancel out just right. And it turns out, if you look at it that way, the effective diffusion you've added, by using this instead of that, is just enough to make the local Peclet number. If you compute it with the effects of.diffuse, the effect is the same as the effect of the diffusion you'd added if you'd chosen a different form of diffusivity. And that's how you get the local number. this d effective, to stay less than 2. Which is what you need as a condition to make this numerically stable. So I strongly suggest you read that. It's only two pages long in the textbook. Just read, just look at it if you haven't seen this. If you've never seen this, it's very clear. Justread it, just read it. Just Read it, Just Look at It. Just Look At It, Just Read It, If You haven't Seen This, Just read It. before. In that case, there was a region of the boundary here that had some concentration c naught, and then there was, over here, the concentration was zero. There's a similar thing and it might be relevant to the COMSOL problem that Kristyn showed you on Monday, is you can-- in that case there was some concentration over there that was zero, and some over here that was some. It's similar to the problem we showed on Monday of how to find the center of the circle. The boundary is zero. Here, it's some number, 17, whatever number it was. And if you think of how to model what's going on, one way to look at it is, I have a diffusive flux coming in from the drug patch, diffusing the drug into the flow. And I think that's a good way to think about it. I don't think it's a very good way of thinking about it, but I think it is a way of looking at it. have this big, giant flow, flowing along here. And the flow gets slower as I get closer to the wall because of the friction with the wall. And so if I looked somewhere right in here, I could just draw a little control volume, and look what's happening. I have this big,. giant flow,. flowing alongHere. The flow is controlled by a control volume. The control volume is called the flow volume. It is a kind of control volume for the flow of water. a diffusive flux coming in here. So basically, it's coming up and it's making a right-hand turn. And so then I could think, well, if I was going to try to. try to get a drug up here, so there's no drug coming into here. But I have drug leaving. So then, I could say, 'I don't have any drug up there, so I don't need to get it here. I just need the drug leaving' figure out, what's the steady state concentration of drug in there, I could say, well, there's a certain amount of drug entering from the diffusive flux, which would be just this times dcdy. This is the y direction. And then this part over here would be the velocity, actually, just the velocity of the drug entering the body. That's how I would work out how much drug was in the body at any one time. I could do that for a drug, for example. times the concentration I have in here, right? So how much is flowing out. And it's probably, my units are screwed up so there's-- Well, maybe not. That's OK. You guys will get it right. It's probably an area. Something to do. You'll get it wrong. It'll be OK. It will be fine. I'm sure of it. You're going to get itright. You've got to. You can do it. There's something to do with it. with this size right here. This one here, too. Is that right? So you could compute what the steady state concentration would be if it's just coming in and flowing out. And so, this is the finite volume view of this kind of problem. and so you can write the solution to the problem in terms of this. size. This is the size of this problem. Andso you can writing the solution in this way, too, if you want to do it in a different way. equations that way, instead. And what you really care about are what the velocity flows and the diffusive fluxes are on these boundaries around the point. So you don't try to compute things right at the point, you compute around it. And one way to look at this is, we don't look at velocity flows, we look at diffusive flows and velocity flows on the boundaries of these boundaries. That's a different way of looking at it, but it's the same principle. just did finite differencing. We were looking at what was happening coming in. And then, this is actually a center difference around this interface, which is halfway between the two points. And so actually,this is a good approximation for the finite volume point of view. This is all right? This is the center difference. We're looking at the interface, and then we're looking down at the volume. And we're trying to see what's going on in this area of the room. And that's what we're doing. Now, these are all different ways to write down the equations. All of them are correct in the limit that delta z goes to zero. If you have an infinite number of mesh points, all these are exactly the same. But they lead to really different numerical properties when delta z is zero. For example, if you have a number of points that are infinite, all of these are the same, but if you only have one point, they are not. That's a very different result. z is large. And they're all inaccurate when delta z is large, so it's all about what happens with the inaccuracies. Now, we can go ahead and take any problem, even really complicated 3-D problems or 4-D problem like this, and we can write them with relaxation methods. And what do you think? Share your thoughts in the comments below or post a video on our Facebook page, @CNNOpinion. Back to the page you came from. we're basically doing in a problem like this is turning it into some function of y is equal to zero, where y is the value of all the unknowns. And there's a lot of equations. So I might have 100 million equations and 100 million unknowns that are the values, and I'm trying to find a way to make them all equal. That's what we're trying to do in this case. And it's going to take a long time, because it's a very complex problem. or every state variable at every state point at all times. Any way I want, I can write down an expression like this. And I know in the limit, as I make the number of state variables, I will have to write it down in some way. I can do this by finding differences, by finding elements and by finding volumes. I know that I will need to write down some form of this expression at some point in the future. I have to find a way to do it in some form. elements of y go to infinity, it will actually be the real solution. And the problem is, my computer can't handle infinite number of unknowns. And so, I have to figure out what to do. So how do I do that? I don't know. I'm going to have to think about it for a while. I think I've got an idea. I'll let you know what it is. It's going to be a lot of work, but I think it'll be worth it in the end. would I solve this normally, is I would take the Jacobian of this and I would do, I'd take an initial guess and I'd update it. You guys have done this a number of times, so I'll do it the same way. I'd have to take my change from the initial guess to the equal negative of f, right? I'd do it that way, and it would be the same as my initial guess. I would have to do that the same thing with my change, and that's how I'd solve this. As Newton-Raphson is how you'd find improved from an initial guess. This is actually pretty hard if you have 100 million unknowns. You have to provide the value of the initial guess for every one of the 100 million.million times. But somehow, somehow, they find a way. to work out how to do it. It's not easy, but it's a start, and it could be the beginning of a new era in the world of computer science. It could also be the start of the end of the age of computers. you did it. And now you want to refine that guess and this is the formula for it. But the problem here is that now f is a 100 million long vector. And so, you just use backslash, right? But the Problem is that Now f is A 100 million squared matrix. And a 100. Million squared matrix is a long vector, so you have to multiply it by 100 million to get the length of the vector. You can do this by multiplying it by a factor of 100 million, and so on. The Jacobian.million squared is pretty big, 10 to 16th elements in it. So I'm not going to just write that matrix down directly like this. Now, we cleverly chose local basis functions, so this is going to be sparse. So most of the numbers, are those 10 to the 16th. elements in the Jacobian, which is the size of the world. The Jacobian is the square of the number of elements in a matrix, and it's the square root of the square of the number of elements. 16th numbers in this matrix are zero. So we don't have to represent them. But there still might be quite a few. Probably the diagonal events are non-zero, so that's like 10 to the 8th of them right there. And we've got, probably, a couple of other bands. So I don't know how many there are, but I think there are at least a few of them. I think that's about 10-12 of them in the matrix. There are 10 to the 9th non-zero elements inside this thing, which is pretty nutty. And depending on how much memory they provided in the laptop they gave you, you might be filling up the memory already just to write down j.don't know. And certainly, if you tried to write it down, it might be 10 to 9th out of the 10 elements inside the laptop. It's a pretty crazy thing to be able to do, but it's also pretty fun. do Gaussian elimination to solve this, you're going to have a problem because you get what's called fill in. Do you guys remember this? Even if you start from a very sparse Jacobian, as you run theGaussian elimination steps the number of non-zero entries in the intermediate matrices gets bigger and bigger. Even if we start with a very small Jacobian we get more and more non- zero entries as we go. We get to the point where we have to do Gaussian Elimination. larger and larger. Remember this? And so, even if, initially, you can write down j and store it in your computer, you could easily overwhelm it with the third iteration or something. So you're not going to just use Gaussian elimination. So what do you have to do? You want. You want to write down the word "j" and then write it down again, and then again and again, until you get it right. You can do this by writing the word j and then writing it again. to find a method. They're called direct. Direct methods to solve this kind of problem, in order to get your increment, which is going to be your update, to get a better estimate of what the solution is. And the direct methods are ones that you don't actually store the data in the first place, but in the second or third stage of the process. It's called a direct method, and it's used to get an estimate of how much data you need to do something. gigantic matrix. So you're trading off CPU time for memory. Which we, normally you would do this with Gaussian elimination and huge steps. It would solve it perfectly, right? Right, Gaussian Elimination's great, backslash. You guys have used it. Backslash is a great way to solve this problem. Back to Mail Online home. back to the page you came from. Back To The page you were from, back To The Page You Came From. a few times. It's a really nice program. It always works. But you're going to give up that because you can't afford it because the memory, it's consuming too much memory and your cheapo department didn't buy enough RAM in your computer for you. So you's going to go back to the old way of doing things. You're going back to what you used to do. You've got to get used to it. You have to get use to it again. to instead try a direct method which is, so it's trading off CPU time versus RAM. So you're going to reduce how much memory you actually actively have, but you'regoing to expect that it's going to cost more CPU time. Because otherwise, everybody would do something else besides Gaussian. And that's what we're trying to do here. We're not trying to make you do anything you don't want to do. We just want you to be able to do what you want with your computer. elimination all the time, and they don't. All right, so what's the method we're going to use? It turns out that variance on the conjugate gradient method turned out really well. So we mentioned this earlier, briefly. What you do is, instead of trying to solve this, you try to. You try to find a way to get around the problem that doesn't lead to a loss of information. That's what we tried to do in this case. solve this. So you just try to minimize that, right? You know at the solution this is going to be zero. Right, jy plus [INAUDIBLE] zero when this is solved. And so you try and vary and find the delta y that makes this go to zero by minimizing it. And that's how you get to the solution of the problem. And it's a very simple problem. It's just a series of steps that you have to take to solve it. then this method, it turns out that the conjugate gradient, if everything works great, this is guaranteed in n iterations to go directly to the solution of this kind of problem. Now n is large, now, because we have 10 to the 8th unknowns. So that's 10 toThe 8th, that's n to the 10th. That's the solution to the problem. So this method is guaranteed to work. It's guaranteed to solve the problem in n iteration. iterations. You do anything in 10 to the 8th iterations, you're not really sure it's really going to work. So that's a warning. But at least it should get, even after a few iterations. You should get a smaller value of this than you had before. And so this is what we're going to try to do with the code we've been working on for the past few days. It's not going to be perfect, but it's going to get better. the method. And what's really nice about this method, if you look into the details of how it works, it never has to store any intermediate matrices. So all it needs is the capability to multiply your matrix times some vector. And from that multiplication, it figures out a step to do the next step in the algorithm. The method is available on Google Play and is available for download from the Google Play Store for Android and the Apple App Store for iOS. It is not available for sale in the United States. direction. And because it only has to do a forward multiplication, you don't have to actually store j. You can just compute elements of j, as needed, in order to evaluate this top product. This j times v.direction. That's the trick of this method. And you don’t have to ever. ever store j, because it doesn't need to be stored at all. It’s just a way to get the top product of a multiplication. And it’ll never be used for anything else. store the whole j at once. So it's really great for RAM to do this method. Now, as I said, when you do 10 to the 8th iterations, things don't always work out so well. And so people have found that when you go more than maybe 10 or 20, things aren't always going to work out as well as you'd like. But it's still a great way to store a lot of data at once, and it's a really good way to do it. iterations like this, you tend to pick up numerical problems. And so, they've worked out better methods. And there's one that people use a lot for these problems called bi cg stab. Which is biconjugate gradient stabilized. The applied mathematicians went crazy trying to figure out better ways to solve these problems. It's called biconjunction gradient stabilized and it's used a lot in the math world. It can be used to solve problems like this. And this is the one that, I think currently, people think is the best. Though probably, there's a lot of research on this, so maybe there's even better ones now. But inside Matlab, I Think this isThe best on they have. And this is a method for doing this. It's a way to get the most out of your computer. It doesn't have to be expensive, it doesn't need to be complicated. It just has to be a way of getting the most from your computer, which is what this is. Now, it's iterative. Now, let's remember what we're doing. We're trying to solve this problem. We started with a guess. We are going to break it up into an iterative problem like this, where we're going to do some steps, delta y. This is now doing iterative procedure in order to solve the problem. It's a guess that we started with. It is now a problem that we can solve by doing some steps. We can solve it by doing steps, Delta y. compute delta y. So this is going to be a lot more CPU time. And it's also, it's not guaranteed like Gaussian elimination, to beautifully come to machine precision solution. So we have an interim procedure and another iterative procedure inside the first iterative process. So just to warn you. It's also not guaranteed to be machine precision. We don't know if we'll ever get there. We'll have to wait and see. But we're going to try and get there as soon as possible. It's going to get you something. But anyway, this is what people do. So that's one good thing to try. Now, this whole approach is sort of based on Newton-Raphson. We know that doesn't have the greatest radius of convergence. So you need to provide a pretty darn good initial. It's not going to be perfect, but it's one of the first steps. It will get you to the next step. It won't be perfect but it'll get you there. guess. So how are we going to get a good initial guess if you have a 100 million unknowns? So what methods do we know? So one idea is you could do things like homotopy, stuff like that. If you could somehow take your PDE system, get rid of the guessing part of it, that would be a good first step. That would be the way to get to the right answer. That's what we're trying to do. We're looking for a way to do that. nonlinear terms. You're really good at solving linear systems of PDEs. You start with that and then you gradually turn the non-linear term on. Maybe you could coax it over. So that's one possibility. Another possibility that I've run into a lot is the Non-Linear PDE. That's the one possibility, if you're really bad at PDE's. And that's the way to do it, I think. I'm not sure if that's a good idea. problem you're trying to solve, for example, might be a steady state problem like this. Where this is zero and you try to figure out what the steady state situation is in a flow reactor. And so, it's actually, your steadyState problem came from a time dependent situation. It's actually a steady State Problem. And it's a time-dependent problem. It comes from a steadyState Problem. That's what we call a steadystate problem. And we call it a steady-state Problem. problem. And if you think that your time dependent problem really converges to the steady state problem, sort of without much concern about what the initial guess is, then you could put any random initial guess in and march it along in time enough, and eventually, it should end up in a steady state. If you think you can do this, you should be able to do it in a matter of hours, not days or even hours, if you have a good idea of how long it will take. at the solution you want. So that's called a time marching idea. So there's one idea, sort of the homotopy continuation kind of idea. Another idea is the time march idea. And the key about it is that you have to start with an idea and work your way up from there. That's the idea of a time march. And that's what we're going to do in the next few days. We'll see how it goes. We've got a lot of work to do. is, you have to really believe that, physically, the system does march to the steady state you want. If it does, then this is a good idea, if it doesn't, then you're not going to end up where you want, because it's not going where it wants to. And so, you. have to believe that that's what's going to happen, and that's why it's so important to try and get it right. If you don't, you're going to be in for a long haul. have to watch out. But in some situations, this is true, that things work. So I do a lot of combustion problems. A lot of these things, you light a spark on a stove burner. No matter how you light it, it ends up basically the same flame. So that's what I'm trying to get at here. I don't want people to think that I'm saying that all the time. I'm just saying that in some cases, it's true. a good one. But I have some other ones where I light a candle and I'm in a convective field, a turbulent field, and it flickers. And no matter what, it always flickers, and I never get a steady state. So I'm never going to find a steadyState solution. I'm not going to be able to get there. I don't think I'll ever get to a steady State. I just don't know how to get to it. with that one. And so I could time march until I retire. My computer's still burning CPU time all that time and it'll never get to a steady state solution. So you really have to know what the real situation is. But if you have one where it's going to be going to the next level, that's a real problem. That's where you have to go to find a solution to it. And that's what I'm trying to do. I'm not going to give up on it. converge, then this is a reasonable idea. Now let's talk about the time marching. The time marching, you have, say, dy, dt is equal to some f of y where this is the discretized spatial vergence. I took all the space dimensions and replaced them with the finite difference expressions. Then this is what we're going to do with the time march. It's a very simple thing to do, but it's a lot of work to get it right. for the derivatives. Or I did colocation or something to convert this into algebraic equations. So the right-hand side is now algebraic. equations, no longer differentials. And now, I'm going to time march this and I just-- This is very long. It's a 100 million. So how are we going to go on with this? I don't know. I just want to get it over with. I want to know how we're going to do it. to time march that? Well there's kind of two schools of thought for this. One school of thought is, if I can use an explicit method, an explicit ODE solver, those are pretty nice. Because all I have to do is evaluate f and then I can march along and time march. Because I can say, 'I'm going to time march this' and then time march it. And so on and so on. It's a little bit like that. I never have to save any matrices. Because remember, look at those formulas, y, y new, by the explicit method, is equal to some function g of y old. And this is the update formula. It can be forward Euler, it could be RK 2. It could be whatever. But it can't be forward RK, it can only be Forward Euler. And that's what I'm going to do here. I'm not going to save matrices, I'm just going to update them. there's just some explicit formula. I never had to do any inversions of matrices or anything. So that's good. And this is, indeed, the way that the Navier-Stokes equations are solved currently by the best possible solver. So the old vector. I plug in the old Vector. I compute a new vector. The old vector is replaced by the new vector, and so on. The new vector is then used to compute the new one. And so on and so forth. best solver in the world discretizes in space and then does ODE IVP using explicit method for marching it. They do problems that are pretty big. So they'll have like 100 million mesh points and then 100 species. And at each time they have 10 to the 10th unknowns. And they have to work out how to solve each of them at the same time. It's a very complex problem, but they do it very, very well. It takes them a long time to solve. step, you're computing another vector that's 10 to the 10th long. So it's a pretty big problem. And they use, like, 40% of one of the national supercomputer centers will be running at one time for one job like this. But it works. You never have to store anything that's. That's a big problem, but it's not a huge problem. It's a very small problem, and it can be solved with a lot of computing power. too big. Now, this is really good if an explicit solver can solve it. The biggest thing you have to store are the vectors. Which, you're always going to have to stores some object the size of your solution, right, if you're going to get your solution. So that's one possibility. But that's not the best way to get the solution, I don't know if that's a good way to do it. I'm not sure if it's the right way. it. So that means it's just not stiff, your problem. And also, if you want a time accurate solution. So in that case, they actually want the time accurately solution. But suppose we're trying to really solve the steady state problem over here. Then we really don't care about the stiff part of it. It's just the time accurate part that's the real problem. That's what we're looking for, and that's why we're using it in the first place. time accuracy. In the end, we're only going to report our steady state solution. That's all we cared about. So in that case, there's no reason to try to have a really high accuracy, explicit formula and try to make a really good time estimate. We're not going to do that. We just want to make sure we have a good steady state. We don't want to have to worry about time steps. We want to be able to say that we've made a good, steady-state solution. sure we all our time steps are exactly right. We're just going to throw away all those time points anyway. We'll just keep the final one as our initial guess for a Newton-Raphson solve to find the steady state. So in those cases, you might instead want to use-- In those cases,. you mightinstead want toUse the time step from the previous step. The final step is the one you took to get to the Steady State. The time step is from the first step to the second step. this is time accurate. There's another method. I don't know if I should call it time inaccurate. If you don't care, if the solution is really, what the solution yft is, all you care about is where you get to, then you can do other methods. And one of them is one of these methods, and it's not time accurate, but it's a good way to get to it. It's a way of getting to the top of the mountain. is the backward Euler. So you can say, well, y new is equal to y old plus delta t times f of y new. Now, the advantage of this is, I can make delta t pretty large. This is guaranteed stable as long as the ODE system is stable. Remember? This is the same as saying that y old is the number of times that y new has been added to it. It's the same thing as saying y old and y new are the same number. And so, this will go to this, go to the solution pretty well, to the steady state solution. It won't go there in the right amount of time because this is a very low order of formula. It's not really accurate. But it will end up to the real steady state. It will go from this to this pretty well. And so, it's not accurate, but it's going to go from here to this. And it will go back to this very, very soon. state solution. This is what's actually used a lot. However, the problem with this is, this is now an implicit equation. So we may have to solve it with some method like Newton-Raphson. But we got into this because we couldn't solve our Newton- Raphson steps because we didn't have a state solution. We got into it because we weren't able to solve our steps with a state-based solution. But now we have a solution. good initial guess. So then the question is, can we find a good initial guess for this problem? And in this case, you can because you can use the explicit formulas to again provide the initial guessing for this implicit formula. So that's what they do, also. And so now, now, we have a solution to the problem. We have a new way of solving the problem, and we can use it to solve other problems. We can use this to solve problems in other ways. if we're doing an iterative procedure in order to get the initial guess for our other iteration procedure ever there, which we're going to break up into another iteration procedure inside it to solve every step. But this is currently what people do. So you guys are smart. Maybe you can do it, too. You're very smart. You can do this. You are very, very smart, and you are going to do it. You have to be smart. It's the only way to go. can figure a better way to do it. The world is waiting. By the way, actually just names-- This kind of thing is called method of lines. And if so, if anybody ever says I solved something by method of line, what they meant was, "The world is Waiting" I think I'll stop there. I've got a lot more to say, but I'm going to take a break. I'll be back in a few minutes with a little more of the story. they discretized in some of the coordinates and they kept one of them as a differential. And then they solved it with an ODE solver at the end. And in certain systems like this, it's a smart thing to do. You need to be kind of lucky that the coordinates are in the right place. It's not always easy to get the right coordinates in the correct place in the first place, but it's always possible to get them in the wrong place in a certain way. set up is right, so you can use it. But if you can, it can be pretty good. All right. See you on Friday. Back to Mail Online home. back to the page you came from. Click here for the latest from CNN.com. Back To the pageYou came from the page You came from: Back to the Page You Came From: Back To The Page You Were Originally From: The page you were originally from: The Page you were initially from: the Page you started from.