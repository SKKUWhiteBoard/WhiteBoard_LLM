Theory: Every connected triangulated manifold -- this is a very general result. We're going to think about two dimensional sources in 3D, but it could be D dimensional surfaces in D plus 1 dimensions. The only catch is that every face has to be a triangle. We've even implemented this algorithm here. It actually holds in any dimension. We don't know about edge unfoldings. The other thing that could go wrong is once you have octagons, even if you could find a way to fit them together. Theory of the facet-path: A path that alternates between visiting faces, triangles, and vertices. Professor: It's an open problem for something like a cube where you actually have quadrilateral faces. He says the claim is facet- Paths always exist for any triangulated, connected surface. The theorem works not only for a polyhedron-- it works for any manifold, any sort of locally, two-dimensional thing, he says. "It's useful because then, what's called a non-crossing Euler tour. Point is you've got a bunch of cycles that touch" to work for discs just as well. So ideally, I cut it all apart into lots of little triangles, but it has to stay connected. So I'll unfold it. Why not? So I can add some cuts until I get down to a spanning tree of the faces. That will cause you make two vertices of odd degree. But that's OK because there's still an Euler path that starts at one of the vertices and visits all the other edges. And I just need a path. You can actually characterize when you get a cycle. It's when the original thing is not too colorable. In the case of a triangulated polygon, we usually call them ears. So imagine those guys as being done. I'm left with these four triangles, actually, a little boring because I don't get the Mickey Mouse case. But then, this will be an ear. This will be a second-level ear. And so I'll end up doing this. And this is actually the base case, if you will. So in general, I just pluck off two or three triangles, repeat until I get one of the base cases. original thing, we think of this triangle as being an ear, and this triangle is an ear. I like ears because they're kind of on the boundary, on the surface, so they're just triangles that are adjacent to only one other triangle. Now, the next step is to color what are called the second-level ears. If you remove those ears, what would, then, become an ear? That's it. Unless there's only four pieces left. Right? PROFESSOR: Sorry, what do you mean? even attached to these cycles, so it's kind of a problem. That's step five is we're going to fix all the problems. Connect cycles together. So that's a local change, and now, it will be one big cycle. We've probably seen this trick once or twice before, I think in the Mountain Valley assignment stuff. So, that'd be a great title. That would be a good title for a book. It would be called, Connecting Cycles. The general approach is always proceed rightward in the unfolding. The amazing thing is that this is possible. You could only do it in a computer because you'd beicing things, and it would fall apart. You can unfold every orthogonal polyhedron this way. I would love to see an implementation of this algorithm. Jason? You've been making these gadgets. I guess I'm not going to describe how this works, but you could reconstruct it from these diagrams. Joe Oogonal: This is what we call an Orthogonal terrain. you can see like a mirror on the bottom. And our parent tells us you have to start at s, and it says you better finish at t. There's no flexibility there, but it could be there are pluses and minuses. But if there's going to be a problem with this theorem, there have to be plused and minused. That's the proof by contradiction. It doesn't look good. It would mean this is like a linkage. It just happens to be on a sphere. Forget this on. face at a time, you can't do that, but if you visit faces multiple times and kind of weave around in a clever way,you can do it. So if you follow along here, I just turn right here. So now, I go down here. And that is a left turn because it's on the bottom, a little hard to think about. So I turn left here, and then, we can zoom out, and you get the unfolding. They're so much fun. It's like exploding a city. Boom! work if it was rotated 90 degrees. It's really powerful. It also works if t is on the other side of s. You could do sort of the mirror image traversal. Now, obviously, I didn't cover the entire surface. I'm leaving room for later, but if this was all I was going to do, I would actually sort of fill out all those strips, just kind of extend them. It just makes this kind of fatter. So this got a little bigger. I've got the first half and then, the second half. This is really glued up there. The algorithm works by recursively undoing everything that you did in this diagram. At every level of the tree, you're going to double what was below you, so that's why you get exponential. If your tree happens to be nice and balanced, doubling is not so bad because here you'll have constant. This will double everything below, but there's only log n levels. So is that linear? It should be about linear. It's certainly 2 to the theta log n, and it matters what this constant is. So ideally, k is one, and you're not subdividing at all. But maybe, you take every rectangle, divide it in half. Maybe that's enough to then be edge unfoldable. That would be sort of a refined level two grid-like unfolding. There are a ton of results about this. They're all partial. One thing you could do, with merely 5 by 4 refinement, is something called Manhattan Towers. Let me show you a picture of Manhattan Tower. how to grid unfold. That's an open problem, but if you refine just in z by a factor of 2, that's enough to unfold. So 1 by 2 refinement is enough for orthostacks. Now, you could go a little crazier and allow vertex unfolding of Orthostacks with some grid refinement, and in that case, you don't need any refinement. So grid vertex unfolding orthostack was the title of paper. These guys, John Iacono and Stefan Langerman. And it looks something like this. other open problems. This was genus 0. Interesting question is can you do genus higher than 0? Orthogonal polyhedra. I would guess so, but I'm not sure. I think the biggest question is, can you make this non-orthogonal? But then, the bands get messy. Haven't been able to do that. All right. I'm going to take a break from unfolding now and switch the other direction of folding. So with folding, we're imagining we're given some polygon, and we'd like to make a polyhedron out of it. It's exactly the reverse of what we've been thinking about. When is this possible? glue whole edges to whole edges. If you want something sphere-like, in fact, those gluings have to be non-crossing. The gluing tells you locally what the surface looks like, even though you don't know what it looks like in 3D. If I want to make something convex, there's only one thing it could possibly make. Finding out what that one thing is is quite a challenge, but at least, we can prove that it's unique. If you have two convex polyhedra and they are combinatorally equivalent, they have the same way that things are connected together, and they have congruent faces, then, they are actually the same thing, the same polyhedron. Different faces can be different, but they're identical in pairs. This is not true if you allow non-convex realizations. These have exactly the same combinatorial structure, same geometry on each face. But as long as they're convex, they're going to be the same. a sphere. Think of it is as almost flat. What that would mean is there's some other way to draw this thing. Basically, there's a way to flex this linkage so that all of these angles increase and this one stays the same. How could I get a polygon where all the angles increase  and still be convex? Ain't possible. Why is it not possible? I think we've used this fact a couple lectures ago. It's not possible by something called the Cauchy Arm Lemma. And here's the thing. If you have a convex chain but open chain here. There's a missing bar. true just viewing p prime as p and p as p prime. If there's anything in there other than zeroes, there has to be at least one plus and one minus. Alternation is either going from plus to minus or from minus to plus. If I little bit because now, we can talk about number of alternation is at most two times the number of triangles. 7 f 7, 8 f 8, 9 f 9-- I'm going to be clever at 5 and 3. might think, well, what happens if there's only three vertices. Well, yeah, you can't have those four alternation because if you have a triangle, even on the sphere, triangles are rigid. We're only interested in cases where it might flex locally at a vertex like the pentagon, like a quadrilateral. All right. So what? This was true at every vertices that was not entirely zero. This works as long as there's at least one face. And that is Cauchy's rigidity theorem. a capital V. We're going to use a trick. It has many names, I suppose. I usually call it double counting in combinatorics, where you have one quantity, namely, the number of alterations. We'll get two different answers, but we know they must end up being the same. And then, we'll get a contradiction. The other natural way to count angles is by looking at the faces. It's sort of the dual perspective. Every phase has a bunch of angles that have some degree or whatever. have a face of 2 k or 2 k plus 1 edges, then it will have, at most, 2 k alternations. I'm going to try and prove an upper bound, sandwich it between, and show that, actually, the upper bound is smaller than the lower bound, and that's a contradiction. So this is kind of obvious. Right? If you have 2 k vertices, no more than 2k alternations, slight, the place where we're making a little improvement is for the odd case. is half-- what is the degree of degree 3 faces? 3. What is thedegree of degree 4 faces? 4. And so on. So now, things are starting to look similar, and I want to get some cancellation going on. Use my cheat sheet here. I'm going to rewrite this formula as V equals 2 plus E minus F. OK? All I did here was decrease by-- well, because there's a half out here, I decrease each coefficient by 2, nothing surprising.