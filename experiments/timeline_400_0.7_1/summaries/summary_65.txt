well welcome back everybody to uh the last lecture 162. this is kind of a a special lecture um i did get some requests for more information about distributed storage and quantum computing and so i think we're going to do that. i want to make sure that we talk through the chord algorithm since that's a i think relatively simple thing to understand and is uh very cool and applied pretty much everywhere so if you remember one of the things we talked about last week was basically this cap theorem which was really a conjecture that eric brewer put forth back in the early 2000s. node except that in reality what happens is this gets distributed over a whole bunch of nodes and so the question is really many parts to this question one is how do we actually do that distributing another is when some client does a get how does it figure out which node to go through. So today i want to tell you about the cord uh algorithm which has been turned into storage systems of many sorts including those used by amazon et cetera okay facebook so um before we get there i wanted to remind you of this notion of recursive versus iterative lookups.  consistent hashing is a way to take your keys and figure out a clean way to distribute them throughout the system without having to know pretty much all of the nodes that are participating. The chord algorithm lets you get by with only knowing essentially a logarithmic number of nodes in the total system and you can still do this well so we're going to associate each one of those storage nodes is going to get a unique id okay and that unique id will be in the hash space. This is basically going to be a mechanism to divide our space up and we'll talk about that in the next slide. So imagine you take their i don't know their ip address and their owner and whatever you concatenate all those things together and you hash them and you get a single 256-bit id out of that now we're going to talk more about secure hashes a little bit later in the lecture. Every node has an id and it's going to be in this ring space this unit dimensional space from 0 to 2 to the m minus 1 where m is big okay and so let's just say there's a lot more slots on here than 64. Cord is a system that was developed uh with a group of researchers at mit and at berkeley. It's the simplest and cleanest algorithm for distributed storage that i have seen and it's a comparison point for all sorts of other algorithms. The way to think about this is we put a bunch of storage nodes on this ring and then we're going to decide where to store our key value pairs based on where the key is on the ring. After four to eight and fifteen is gonna store everything from nine to fifteen and twenty is gonna storage everything from sixteen to 20. Nodes are connected based on their hash names. Because of the hash being a randomizing function uh we've scrambled the geography of this ring. No particular part in the in the world here might be a hot spot it means unfortunately though that we don't have the most local of look up because if we start at node four it'd be nice if we could just go down to 15 and back okay now this is a really good question here about redundancy how do we get redundancy out of this for the moment. beachfront property in nevada and then has a plan to basically cause uh california to fall into the ocean and therefore have really expensive properties fortunately superman uh saves the day and it doesn't happen so um okay so if we move um forward with this by the way i'm showing you these clients now to make this a little more clear the clients need to know one gateway into the system in order to talk to the system okay so that's going to be part of the initial lookup. about this algorithm is all that the ring is going to do is it's going to figure out who is responsible for storing key 50. So just by asking the ring where key 50 belongs it now has some information about nodes that it can talk to. If you lose two nodes in a row then what i've just described to you is no longer going to work. There is a way to completely break the ring such that the stabilized procedure won't reconnect it. We have figured out how to make this stable so first of all as long as we have a fully connected ring. The power of the powerful thing about this is once i've got all these nodes now i can do a really fast routing process to figure out how to find which node is going to store the key i'm interested in. If you have log m where m is the number of nodes of the system you can end up with a situation where you can find data even if half of your nodes fail. So that's kind of what's proved in that chord paper and that's not that many because it's a logarithmic number. algorithm and so what's good about this is like i said you store the data in the cord ring and it it's very hard to destroy okay why are they called leaf sets that's a good question the reason they're called Leaf sets is because in some sense you can view the uh if you take any given um starting node like 58 and you view the set of fingers that're a tree and so eventually you get to the leaf set and so it's like a tree with leaves so that's where the leaf is coming from. Chord algorithm is sort of geographically distributed by nature. The randomness is helping us to avoid correlated failures where yeah we have a bunch of copies but they're all in the same machine room and the building got struck by lightning so that doesn't happen in a chord algorithm. The downside of course is performance might hurt if you happen to be too far away from a copy um and so i will tell you that there are subsequent versions of cord which uh when you're doing this routing and you have a lot of options here. what we did with the the tapestry lookup process back for ocean store okay so i did want to point out that what i've just described to you this chord ring is actually used in lots of uh cloud services these days. For instance dynamodb and i have a paper for that up on the reading from last time uses the chord rings and you can look down here but it uses them within their machine rooms as a way to distribute load. So basically you have a service guarantee that says we'll get a response within 300 milliseconds uh for say 99.9 percent of the requests. it adapts automatically which is pretty good okay so what i wanted to do next uh i'm going to talk a little bit about security and then um talk through a couple of things and then i want to uh try to get to quantum computing as well so we can i know there was some of you asked some questions about that so i'mgoing to leave this topic unless there's more questions okay. Security is kind of dealing with actions of a knowledgeable attacker who's really trying to cause harm and we want to make sure that uh they can't really screw us up okay. security policy built with our protection mechanisms okay so i wanted to point out something interesting i don't know if you've ever seen this before but here is a car in the ditch. Back in july of 2015 there's a team of researchers that took complete control of a cheap suv remotely exploited a firmware attack over the sprint cellular network. They basically caused the car to speed up and slow down and and veer off the road and uh totally wirelessly so this is a little scary.  cryptography is one of the central points of many of these mechanisms you just have to use it correctly. This is communication that's in the presence of adversaries uh it's been studied for thousands of years. If you have a good algorithm like aes it's not possible for an adversary to send a message that the receiver will treat as real because you have to have the secret key now one thing you do need to do in order to make this work is to use the right algorithm. i'm hoping that if you haven't taken 161 it's on your list because there's a very interesting set of things that people can talk about. single symmetric key encryption work which symmetric because the same secrets used at both sides is to prevent a adversary from holding on to an old message and sending it later is you have to start adding what are called nonces which are things like timestamps and so on so that every time you send this it's unique and if somebody sends an old version you can detect it. The idea of a secure hash function is one where you take data and you run it through a hash function and get a bunch of bits out of it. we can take a plain text something like a contract and we can run it through a hash function where we take that key and an append m and that's called a digest now we can send that across and the data. At the other side we can verify by re uh computing that hmac okay and if they match the one that was sent across versus the one you computed yourself then you can know that the message is not corrupted otherwise it's corrupted. Hashing is pretty powerful and i'm not going to have a lot of time to go through this with you that's a 161 topic. Data centric vision is one that i've adopted in uh my research group is one in which we think about shipping containers full of data so if you think about uh down the port of oakland you've probably all seen these shipping containers. This was a a great invention back in 1956 so before 1956 what happened was we had uh longshoremen who would take a bunch of things and they would go to a ship and they'd play tetris with it. Now i can ship something from my house in lafayette to beijing the outskirts of beijing just by calling the right trucks. a data capsule and inside the data capsule is a bunch of transactions that are hashed so remember those hashes we talked about and signed where we uh we use a private key to sign a hash over something and as a result we trust that this really came from the person who said it did because only they could have the private key. As a result of these data capsules this gives us a cryptographically secure way of moving data around to the edge to the cloud and back again in a way that nobody can fake out. that we know and the second thing is of course we can put arbitrary encryption on top of this as well to make it uh private so really the signatures are about integrity and who put the data there and uh the encryption would be about privacy. If you have a signature only at the end of a chain of data you can essentially check the rest of the chain by checking the hash pointers so these are all of the things you get out of a blockchain by the way for those of you that are familiar with bitcoin or whatever. The vision here really is of pretty much everybody using data capsules everywhere okay and if you can get that to happen then you could potentially have a very interesting scenario here. Part of what we're doing is we're working with roboticists and machine learning folks to put their data and their models for grasping and so on inside of data capsules and as a result they can reside securely in the edge in say your robots or whatever in a way that can't be breached okay. This is really targeted at secure edge infrastructure in addition to the cloud so these data capsules can move back and forth. unforgeable all right good so let me say a little bit about using quantum mechanics to compute. It's basically using weird but kind of useful properties of quantum mechanics two of them quantization and superposition. If you're willing to allow things to not be always a one or always a zero what you can do is you can just start doing quantum computing. There are many other algorithms out there now these days these days they've been slowly working on them but these are some pretty good ones that might be interesting. we've got google we've got ibm it's very popular these days with big companies uh microsoft is in here as well looking at building these quantum machines both of these two both google and ibm are super conducting bits so these parts of the machine you see here are normally put into a doer and they're running at four degrees kelvin or something really cold. This particular type of quantum computing technology is not going to be in your laptop at least not in any laptop i'd want to put on my lap but there are other technologies including ion traps that potentially are pretty interesting. are particles like protons or electrons have this intrinsic spin and so now i got one and zero or up and down okay. A representation called the heisenberg representation looks at this uh messy physical situation like this which is either a zero or a one in these brackets. That represents spin up and spin down okay or vice versa depending on how you want to whether what it's looking like if you're with the field then that's a lower energy so that's probably spin zero it's probably zero now. light travel in fact instantaneous travel of information from the earth out to that far planet einstein really didn't like this he called it spooky action at a distance okay but in fact uh what's interesting about this is you can prove that there's no actual information transferred okay so however we can use this to do what's called teleportation um which is take information uh at one side do some measurements send some data to the remote side and recreate the data recreate the quantum state at the other side. high probability some answer that was hard to find that's what we would like okay and so if you look here um you know if the two n inputs are equally probable there could be two to the n outputs that are equally likely. What we'd like is the probability of the outputs to be piled up high on the answer we want and it turns out that something like fourier transform does the trick okay so if we can do a fourier transforms on some input we can actually get an interesting output. With a quantum computer what we can do and unfortunately i guess i don't have time to do this because we're running out of time but i can set up a situation where my input to my algorithm is all the possible k's uh if i take a bunch of values and i compute uh the the value x to that value and i add them all together as a superposition and i do a fourier transform what i'll find is that x to the r congruent to one as i have r go through all its possible values. actually investigated if you were to build uh that factoring algorithm and you could do it as quantum circuits that could run on a quantum computer what would that look like. We actually investigated ways of optimizing that and we could actually look at performance of different options for the shortest factoring algorithms. So we built a cad tool to do that so i i don't know i think it's a pretty interesting area right now and there's a lot of interest in it all right so um sorry i kept you guys way over but this is the last lecture i figured if anybody was interested we talked about key value stores.