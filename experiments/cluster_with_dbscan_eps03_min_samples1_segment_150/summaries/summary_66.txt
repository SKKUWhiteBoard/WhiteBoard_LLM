MIT OpenCourseWare offers high quality educational resources for free. To make a donation, or to view additional materials from hundreds of MIT courses, visit MIT OpenCourse Ware at ocw.mit.edu. The next time I'll be lecturing to you will be a week from Friday. The homework following the quiz will be posted and so you guys can get started on that. That homework involves a COMSOL. The quiz is for students who want to learn about partial differential equations. problem which, for those of you who had trouble with COMSOL, might take some extra time, since it's the first time you're doing it. So I would suggest you at least give it a try early. I'm sure the TAs would be very happy to help you to force COMsOL to cooperate. Bend COMSol to your will. All right, so we're going to talk about partial differential equations. And, as it sounds, what's different about a partial differential equation is, it has partial derivatives in it. a diffusion term, a convection term, and a reaction term. This is part of the Navier-Stokes equations for the whole reactive flow system. A very important thing about partial derivatives, which you probably have encountered in 1040 already, is, it really depends what you hold fixed. And you get different results if you hold different things fixed. Now the implication, when you write this equation, is that the reaction term is the product of the diffusion and convection terms. an equation like this, is that whatever partials you see-- when I wrote this, if I have this and it has a term that's like d squared, dx squared, is one of the terms in this thing. This says t, this says x. The convention is, oh boy, I better hold x fixed. And here must be, I must hold t fixed. Because there's another one in the same equation. Now, you can change coordinates however you want. Just really watch out that you carefully follow the rules about what you hold fixed, when you change things. Otherwise you can cause all kinds of craziness. stuff? Yeah, so you've seen how completely confusing it can be with negative signs showing up all over the place. And other things like this. I don't know if you've encountered this yet? At least, I thought it was confusing when I took it. So just be aware. It's the same thing. Now, often you do want to change the equations. So you can write down an equation like this, but, for example, if you have a special symmetry of the problem, like it's cylindrical, then you might want to changed the cylind spherical coordinates. it turns out there's a special coordinate system called the elliptic coordinate system. And in that coordinate system, the partial differential equation is separable. And so, if you do it in thatcoordinate system, you can actually solve analytical solution, which is pretty unusual for the Schroedinger equation. But it's a pretty goofball coordinate system and you really have to watch out, when you convert, to make sure you're doing it just right. It's just the rules, chain rule and the rules about how to keep track of what's being held constant. methods. So all those methods basically look the same. You just get equations that have more unknowns in them. And so fundamentally, there's no problem, but in practice, there is a big problem if the number of unknowns gets to be so large. So think about it. How many points do you think you need to discretize? Now, these are all different ways to write down the equations. All of them are correct in the limit that delta z goes to zero. But they lead to really different numerical properties when delta z is large. your solution in the spatial coordinate? There might be somewhere, might be 100, I don't know, points might be enough. And so now I have x and y and z. So I'll need, well, just in COMSOL, you saw this on Monday. Suppose I just have two dimensions. And I start putting points in. Well, I want to have some points along this way, and I want a few points along that way. So, I actually have an unknown here and anunknown here, and one here and one there. things they called the d's before in the basis functions. And I have a lot of them. 10,000 unknowns are a lot harder to solve for than 100 unknowns. And once you get up to a million unknowns, we're starting to talk serious. All right? So you can just see how it just gets to be, like, a big numerical problem. So that's two dimensions. The third dimension, you'll get another 100 times as many points. You might have a millionunknowns. math, now. OK? Even for your good computers that you have. In addition, it's not just you have the number of mesh points, but it's the number. ofMesh points times number of variables at each mesh point. So in the Navier-Stokes equations, what variables do you have? AUDIENCE: [INAUDIBLE] PROFESSOR: Louder. What else we got? Density or temperature. So maybe temperature would be what you might use. And then you'd have a state function maybe with these guys. a pretty big set of variables and you need to know all these numbers at each point. So this might be-- how many have we've got? One, two, three, four, five, plus however many species we have? So this is n species plus 5 times the mesh. And I told you the mesh was what, a million? So maybe I have 10 million unknowns. So the issue, to a large extent, has to do with just, can I solve it? physically, then probably we're not going to get a stable solution. So you have all those kinds of problems that we had before in the ODE case, and now it's just sort of amplified by the fact, now we have boundary conditions in more than one dimension. So we have multiple chances to screw it up. And we're trying to figure out how to set the boundary conditions correctly. So those are the different kinds of things we have to worry about. But it's all the same problems you had before, just amplified. up to three dimensions, you might be able to solve it. And then in reality, we have problems like the Navier-Stokes is four dimensions, right? There's time, as well. So then that gets to be really hard. The Schrodinger equation has three times the number of electrons dimensions in it. So that gets impossibly hard. And so, specialized methods are developed to handle those systems with a lot of dimensionality. And there's been a huge effort, over decades, to figure out really clever basis sets that are really close to the real solutions. The PDE system, itself, can be intrinsically unstable. In the Navier-Stokes world, I'll show you what people do to try to deal with that. There's many other problems. I don't know all the problems in the world. But in general, when you have three or more dimensions in your PDEsystem, you're looking up special tricks. You're looking. up, how do people in this field deal with this particular PDE? Special ways that are good for that kind of PDE. the case where it's stable, that it just sits there, a hydrogen and oxygen. Or it could turn into a regular burning. Or if I change the conditions a little bit differently, it could change into a detonation, where it actually sends a shockwave down the tube faster than the speed of sound. So those kind of systems can be really sensitive to the physical initial conditions. A very small spark can make a really big difference in a system like that. And also, in your numerical solution, if the thing is physically sensitive, it'll typically be sensitive also to numerical noise. of a cell culture or the growth of a tumor, as you know, if somebody has a tumor and one of the cancer cells mutates and does something different, it can have a really different outcome. A small change in one cell, for example, could be a really big difference. So this is not just in combustion problems you have these kinds of instabilities. All kinds of problems have this kind of thing. You can have just regular chemical reactors, like in multiple steady states, little tiny fluctuations can make it jump from one steady state to another one. stable in some sense, but it causes a problem. We call those hyperbolic. And those are like wave equations. The solutions are propagating waves. So what happens, then, is you have some numerical noise that will make a little wavelet that will propagate, more or less, without any damping, too. And it'll keep bouncing back and forth inside your domain numerically. And if you keep introducing numerical noise, eventually the whole thing is just full of noise. It doesn't have much relation to the real physical solution. I'm not going to talk about how you solve them in this class, but there's a special, whole group of solution methods that people use who are solving acoustics equations and solving electromagnetic equations. If you get into those things, you should take the PDE class for hyperbolic equations and they'll tell you just all about the solvers for those kinds of things and special tricks. Here, what we're going to focus primarily on two kinds of problems: elliptic problems and parabolic problems. ones where there's some dissipation that's very significant. In an elliptic problem, you introduce some numerical noise and as you solve it, the numerical noise kind of goes away. In a hyperbolic system, information-- there's regions of the domain that you can make a change here and it doesn't make any effect on some domain part over there. So for example, if I'm modeling a shockwave that's moving faster than the speed of sound, I can introduce any pressure fluctuation I want behind the shockwave, and it has no effect on the shock wave. speed of sound. They won't catch up to the shock. So they will have no effect whatsoever. So if I was judging what was happening by looking at what's happening in the shock, I can introduce any kind of random noise I want back over. And it won't make any difference at all. And so, that's part of the reason why I need a special kind of solver. If I have elliptic equations, every point affects every other point. A famous case for that is, like, this steady state heat equation. trying to flow by, sort of, every path. And there's some insulation that's resisting its flow. And it has been in the connectivity of flow a certain way. Those kinds of equations are called elliptic. And the methods that we use for the relaxation mesh that we showed are really good for those kinds of problems. And then another kind of problem that we get into a lot is like this one. This is called parabolic. And typically, in the cases we see that are parabolic, we have time as part of the problem. a flow in a pipe. And you have a nice, fast velocity flow down the pipe. What's happening downwind is very much affected by what happened upwind, but not vice versa. So it has a directionality, even though I might do it as a steady state problem and not have time in it at all. You've probably already done this, where you can convert, like, a flow reactor. You can write it, sort of, as a Flow Reactor. time thing or as a space thing. Time and space are so related by the velocity of the flow. We'll have similar kinds of phenomenon then. It's almost like a parabolic time system. If the flow is fast enough, the fusion backup, anything moving upstream is negligible. And so then, you'll have the same kind of issues. In fact, you may even try to solve it by just starting it at the upstream end and competing stuff and then propagating what that output from that first one does to the next one downstream. very slow, the Peclet number very low, then you really have to worry about things diffusing back upstream. And that would be more like the elliptic problems we have. Because things downstream would actually affect upstream, if the flow is really small. But typically for our problems, the velocity is always really high, and so not much goes from downstream to upstream. It's almost all upstream to downstream. This leads to a famous situation. If you look in the textbook at figures 6.7, 6.8, it's kind of a very famous problem. here and here and change this into this obvious looking thing. You think that that would be a reasonable thing to do, right? And you can do the same one here. You can write-- I'm terrible with minuses, sorry. So these, the finite difference formulas. And so, you can write these like this. This stays equal to zero. And now it's just an algebraic problem to solve. A system of equations, you have equations like this for every value of n. And there's the mesh points. called local Peclet number, which is-- OK? If you make the local PEClet number too large, actually anywhere bigger than 2, and you try to solve this equation, what you get is oscillations, unphysical oscillations. They'll make the phi go negative. It's crazy. It looks like the simplest equation in the world, right? It's a linear equation, so what's the problem with this? But it doesn't work. And so, then you could think, well, why doesn't it work? And there's, like, multiple ways to explain this. at point n plus one, I guess. Here we have the flow this way. So here's n minus one. Here's my point n, n plus 1. I really should not include, is this right, n Plus 1 in this formula. Because I don't think that what happens downstream should really affect this at all. So really, I would do better to change from this center difference formula to what's called the upwind difference formula. Just use that instead of using this formula, and it makes a gigantic difference. when you do that. But where you do this one, you get crazy, oscillatory, unphysical solutions, unless you choose delta z really tiny. So I think this is the correct way, the best way to think about it is, it has to do with information flow. So upwind does not really depend on downwind. If you force it to, by choosing to include that information here, you end up with crazy stuff. Another way to look at it is that, if you really want to compute these derivatives, you've got to keep delta z small. a terrible approximation to do this. You can see that what we're doing is, when we have this problem where the local Peclet number is getting too large, is we're actually choosing delta z bigger than the, sort of, the thickness of the solution. And approximation to the differential. This is a asymmetrical finite difference formula. It's not a very good value estimate of the derivative, if delta z is big. But you can write it out carefully and write this out and say, oh, this actually is sort of like this plus an effective diffusivity chosen very carefully. in fact, you really should have a bunch of points here and here. And so you did something really crazy to use a big value of delta z to start with. Now, the fix, by doing this upwind differencing, I think the best way to look at this is saying, well, I'm just going to make sure I only depend, I only make the equations depend on what's upwind, with the convective term. Because there's nothing convecting from downwind. So just leave that out. before. There's a similar thing and it might be relevant to the COMSOL problem that Kristyn showed you on Monday, is you can-- In that case, there was a region of the boundary here that had some concentration c naught, and then there was, over here, the concentration was zero. Here, it's some number, 17, whatever number it was. And if you think of how to model what's going on, one way to look at it is, I have a diffusive flux coming in from the drug patch, diffusing the drug into the flow. with this size right here. Is that right? So you could compute what the steady state concentration would be if it's just coming in and flowing out. This is the finite volume view of this kind of problem. And so you can write the equations that way, instead. And what you really care about are what the velocity flows and the diffusive fluxes are on these boundaries around the point. So you don't try to compute things right at the point, you compute around it. or every state variable at every state point at all times. And I know in the limit, as I make the number of elements of y go to infinity, it will actually be the real solution. And the problem is, my computer can't handle infinite number of unknowns. In fact, it's even going to have trouble with a 100 millionunknowns. And so, I have to figure out what to do. So how would I solve this normally, is I would take the Jacobian of this and I would do. As Newton-Raphson is how you'd find improved from an initial guess. This is actually pretty hard if you have 100 million unknowns. You have to provide the value of the initial guess for every one of the 100 million.million times. And now you want to refine that guess and this is the formula for it. And so, you just use backslash, right? But the problem here is that now f is a 100 million long vector. And a100 million squared is pretty big, 10 to 16th elements in it. 16th numbers in this matrix are zero. So we don't have to represent them. But there still might be quite a few. Probably the diagonal events are non-zero, so that's like 10 to the 8th of them right there. And we've got, probably, a couple of other bands. So I don't know, might be 10 toThe 9th non- zero elements inside this thing, which is pretty nutty. And depending on how much memory they provided in the laptop they gave you, you might be filling up the memory already just to write down j. Normally you would do this with Gaussian elimination and huge steps. It would solve it perfectly, right? Right, backslash. You guys have used it. But the direct methods are ones that you don't actually store the gigantic matrix. So you're trading off CPU time for memory. And so, even if, initially, you can write down j and store it in your computer, you could easily overwhelm it with the third iteration or something. So what do you have to do? You want to find a method. a few times. It's a really nice program. It always works. But you're going to give up that because you can't afford it because the memory, it's consuming too much memory and your cheapo department didn't buy enough RAM in your computer for you. Instead, instead of trying to solve this, you try to reduce how much memory you actually actively have, but you'regoing to expect that it's going to cost more CPU time. It turns out that variance on the conjugate gradient method turned out really well. solve this. So you just try to minimize that, right? You know at the solution this is going to be zero. Right, jy plus [INAUDIBLE] zero when this is solved. And then this method, it turns out that the conjugate gradient, if everything works great, this is guaranteed in n iterations to go directly to the solution of this kind of problem. Now n is large, now, because we have 10 to the 8th unknowns. the method. And what's really nice about this method, if you look into the details of how it works, it never has to store any intermediate matrices. So all it needs is the capability to multiply your matrix times some vector. And from that multiplication, it figures out a step direction. That's the trick of this method. Because it only has to do a forward multiplication, you don't have to actually store j. You can just compute elements of j, as needed, in order to evaluate this top product. This j times v. iterations like this, you tend to pick up numerical problems. And so, they've worked out better methods. And there's one that people use a lot for these problems called bi cg stab. Which is biconjugate gradient stabilized. And this is the one that, I think currently, people think is the best. Though probably, there's a lot of research on this, so maybe there's even better ones now. But inside Matlab,. I think this isthe best on they have. compute delta y. So we have an interim procedure and another iterative procedure inside the first iterative process. So this is going to be a lot more CPU time. And it's also, it's not guaranteed like Gaussian elimination, to beautifully come to machine precision solution. But anyway, this is what people do. So that's one good thing to try. Now, this whole approach is sort of based on Newton-Raphson. We know that doesn't have the greatest radius of convergence. So you need a pretty darn good initial guess. nonlinear terms. You're really good at solving linear systems of PDEs. You start with that and then you gradually turn the non-linear term on. Maybe you could coax it over. Another possibility that I've run into a lot is the problem you're trying to solve, for example, might be a steady state problem like this. Where this is zero and you try to figure out what the steady state situation is in a flow reactor. And so, it's actually, your steady state problems came from a time dependent problem. at the solution you want. So that's called a time marching idea. So there's one idea, sort of the homotopy continuation kind of idea. And the key about it is, you have to really believe that, physically, the system does march to the steady state. If it doesn't, then you're not going to end up where you want, because it's not going where you wants. But in some situations, this is true, that things work. So I do a lot of combustion problems. A lot of these things, you light a spark on a stove burner. No matter how you light it, it ends up basically the same flame. a good one. But I have some other ones where I light a candle and. I'm in a convective field, a turbulent field, and it flickers. And I never get a steady state, so I'm never going to find a. steady state solution with that one. And so I could time march until I retire. My computer's still burning CPU time all that time. So you really have to know what the real situation is. But if you have one where it's going to converge, then this is a reasonable idea. for the derivatives. Or I did colocation or something to convert this into algebraic equations. So the right-hand side is now algebraic equation, no longer differentials. And now, I'm going to time march this and I just-- This is very long. It's a 100 million. So how do we time march that? Well there's kind of two schools of thought for this. One school of thought is, if I can use an explicit method, an explicit ODE solver, those are pretty nice. there's just some explicit formula. I plug in the old vector. I compute a new vector. So that's good. And this is, indeed, the way that the Navier-Stokes equations are solved currently by the best possible solver. So the best solver in the world discretizes in space and then does ODE IVP using explicit method for marching it. They do problems that are pretty big. So they'll have like 100 million mesh points and then 100 species. The biggest thing you have to store are the vectors. So that's one possibility. Now, this is really good if an explicit solver can solve it. But suppose we're trying to really solve the steady state problem over here. Then we really don't care about the time accuracy. In the end, we're only going to report our steady state solution. That's all we cared about. So in that case, there's no reason to try to have a really high accuracy, explicit formula and try to make it too big. sure we all our time steps are exactly right. We're just going to throw away all those time points anyway. We'll just keep the final one as our initial guess for a Newton-Raphson solve to find the steady state. So this is time accurate. There's another method. I don't know if I should call it time inaccurate. If you don't care, if the solution is really, what the solution yft is, all you care about is where you get to, then you can do other methods. if we're doing an iterative procedure in order to get the initial guess. This kind of thing is called method of lines. And in certain systems like this, it's a smart thing to do. But this is currently what people do. So you guys are smart. Maybe you can figure a better way to do it. The world is waiting. I think I'll stop there. By the way, actually just names-- this kind of things are called method Of Lines. And if so, if anybody ever says I solved something by method of Lines, what they meant was, they discretized in some of the coordinates and they kept one of thecoordinates as a differential. set up is right, so you can use it. But if you can, it can be pretty good. All right. See you on Friday. Back to Mail Online home. back to the page you came from. Click here for the latest from CNN.com. Back To the pageYou came from the page You came from: Back to the Page You Came From: Back To The Page You Were Originally From: The page you were originally from: The Page you were initially from: the Page you started from.