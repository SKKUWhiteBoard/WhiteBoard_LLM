well welcome back everybody to uh the last lecture 162. this is kind of a a special lecture um i did get some requests for more information about distributed storage and quantum computing and so i think we're going to do that. i want to make sure that we talk through the chord algorithm since that's a i think relatively simple thing to understand and is uh very cool and applied pretty much everywhere. If you remember we started talking about key value stores with this notion of a distributed hash table where what i've got in yellow here is really the key value um table that we might think about on one node. there's performance problems and uh scalability issues where we would like to increase the size of the system by just sort of adding more nodes down at the bottom here and um so far we haven't really talked about how to even make that work okay. So today i want to tell you about the cord uh algorithm which has been turned into storage systems of many sorts including those used by amazon et cetera okay facebook so um before we get there i wanted to remind you of this notion of recursive versus iterative lookups so um here's an example of a recursive lookup which is like routing. clean way to distribute them throughout the system without having to know pretty much all of the nodes that are participating so this seems like a strong ask when you think about it if there's hundreds or thousands or millions of servers down here and we have to somehow um consistent with consistent hashing figure out which node to go to without going through a master directory and such that all these nodes don't know about each other. So this is basically going to be a mechanism to divide our space up and we'll talk you through that in the next slide and then i'm going to show you how the chord algorithm lets you get by with only knowing essentially a logarithmic number of nodes. been talking with clients presumably what i know is i know one of the nodes in the system and if you remember this ring has nothing to do with locality that node could be i don't know 8 or 15 or something okay and so what i need is i need this new node needs to know one gateway node i'm going to say 15 just for the sake of argument and what are we going to do to join well we're going to send a join message to the node we happen to know about okay and what's interesting about this algorithm is it's going to figure out who is responsible for storing key 50. will tell you that there are subsequent versions of cord which uh when you're doing this routing and you have a lot of options here see how we have many places we could go. One of the things we can do with chord is we can use chord to store locations of data rather than the data. We can actually take locality into effect to some extent in chord and um and make our routing less like bouncing back and forth across the planet randomly and more like working our way physically toward the thing that we're interested in. have a service guarantee that says we'll get a response within 300 milliseconds uh for say 99.9 percent of the requests okay and so that's part of the way that the chord algorithms are adapted in a read real cloud service. Security is kind of dealing with actions of a knowledgeable attacker who's really trying to cause harm and we want to make sure that they can't really screw us up. quantum computing as well so we can i know there was some of you asked some questions about that so i'm going to leave this topic unless there's more questions okay. about by using new techniques and the distinction between protection and security i think is an important one because protection is the set of mechanisms that we talk about in this class. Security is basically using those mechanisms to prevent misuse of resources so for instance virtual memory is a mechanism that can be used for protection security policy would be making sure that when we use virtual memory we don't let malicious processes or different processes owned by different people use the same memory and have a potential for screwing each other up. that a user who's making changes to the system is really who they claim to be data integrity is making sure that the data hasn't changed okay so that's important confidentiality is makingSure that theData is read only by authorized users so that often involves encryption of some sort. Non-repudiation is a surprisingly important thing that people don't often talk about which is that if one sender makes a statement and they uh send a message or whatever they can't later claim that well i didn't really send out somebody malicious did. hash function is one where you take data and you run it through a hash function and you get a bunch of bits out of it. If you change the data even slightly you end up with a good hash function with something that essentially roughly half of the bits change. What makes this secure is that it's not possible for somebody to come up with another source that matches the hash function. So we can use hashes to prove later that you know after the transmission has happened that the data is authentic. it wasn't uh you know if the integrity wasn't high you know it was basically didn't match then we could know that that firmware is probably bogus and we shouldn't be using it okay now the downside of course of everything we've talked about is both sides share the same key and so if you leak the key then you got problems okay and furthermore you have to somehow share the key so that requires you to go in a dark alley and you know hand the key over and so this seems like only part of the solution and um the interesting thing about that is this idea of public private key pairs. protect everything okay and so if you think about the internet of things really uh one way to look at theinternet of things is that we have a whole bunch of devices and compute elements all over the world and it's really a graph of services that we want to connect. So distributed storage is everywhere every arrow represents communication we've got storage everywhere. We want to make sure that the data can only be written byauthorized parties and only read by authorized parties okay and these secure enclaves are a topic for another day as well. Data centric vision is one that i've adopted in uh my research group is one in which we think about shipping containers full of data. Inside the data capsule is a bunch of transactions that are hashed so remember those hashes we talked about and signed where we uh we use a private key to sign a hash over something. As a result of these data capsules this gives us a cryptographically secure way of moving data around to the edge to the cloud and back again in a way that nobody can fake out. is a is a good one to be talking about um what we know is the following the metadata is uh among other things the public key of an owner hashed okay and so all of these signatures have to be signed by the owner and anybody can verify that um the data that's in here was put in there by the right owner okay so that gives us integrity and providence it means that we can know that none of the data in here could have been put there by an adversary so that's the first um thing that we know and the second thing is of course we can put arbitrary encryption on top of this as well to make it private. The vision here really is of pretty much everybody using data capsules everywhere okay and if you can get that to happen then you potentially have a very interesting scenario here. Part of what we're doing is we're working with roboticists and machine learning folks to put their data and their models for grasping and so on inside of data capsules and as a result they can reside securely in the edge in say your robots or whatever in a way that can't be breached okay. This is really targeted at secure edge infrastructure in addition to the cloud so these data capsules can move back and forth. class but uh what you find out is for instance back in chemistry if you remember from chemistry you had the orbitals right and so only electrons were only allowed in certain rings or spheres actually around atoms. Because it's quantum mechanics we can do the second thing which is superposition and this is having uh a bit which is both a zero and a one in certain fraction of uh between the two. If you're willing to allow things to not be always a one or always a zero what you can do is you can just start doing quantum computing. Those are particles like protons or electrons have this intrinsic spin and so now i got one and zero or up and down okay and a representation called the heisenberg representation looks at this messy physical situation like this which is either a zero or a one in these brackets. What you see here is actually a superposition of zeroness and oneness together okay now you know i realize this looks a little weird we don't normally get a wave function notation in 162. But the thing that's very interesting about this is that this is a description of a combination of zERONess and Oneness where the probabilities can be adjusted anywhere. you do a bunch of computing on it such that the probabilities are kept and you measure okay and the way it looks is that you take uh let's say you put an input with all possible combinations of the input input of the inputs being equal values all possible probabilities it looks like you're doing computation on all possible values at once but then when you measure you pick up exactly one and that's the answer you get okay. If you don't do anything very interesting here this is going to look like you randomly picked some input and computed on it so basically what we're talking about here looks like a random computation. r is odd we got to repeat if r is even then we can say well i know because x to the r is equivalent to one mod n. If we could somehow figure this out what r makes this equiv equation satisfied and we could do that quickly then um we win. That's something that uh you can't do easily classically but with a quantum computer what we can do and unfortunately i guess i don't have time to do this because we're running out of time but i can set up a situation where my input to my algorithm is all the possible k's. actually investigated if you were to build uh that factoring algorithm and you could do it as quantum circuits that could run on a quantum computer what would that look like. We actually investigated ways of optimizing that and we could actually look at performance of different options for the shortest factoring algorithms. So we built a cad tool to do that so i i don't know i think it's a pretty interesting area right now and there's a lot of interest in it all right so um sorry i kept you guys way over but this is the last lecture i figured if anybody was interested we talked about key value stores.